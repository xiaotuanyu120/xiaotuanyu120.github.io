<!DOCTYPE html>
<html lang="zh-cmn">

<head>
    <title>XTY Blog | Linux Ops Docs | SRE | DEVOPS</title>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
    <link rel="stylesheet" href="/static/css/chroma.css">
    <link rel="stylesheet" href="/static/css/main.css">
</head>

<div class="blog-title">
	<div class="container">
		<div class="row">
			<div class="col-lg-12">
				<div>
					<a class="main-title" href="/">XTY的小站</a>
                </div>
                <div>
                    <a class="small-title" href="/">记录技术笔记和技术博客</a>
                </div>
			</div>
		</div>
	</div>
</div>

<body>
  <div class="container">

    <div class="col-lg-4 col-lg-offset-1 col-md-4 col-md-offset-1 col-sm-4 col-sm-offset-1">
	  <div id="sidebar">

		<h3>最新文章</h3>
          <ul>

            <li>
              <a href="/linux/shell/shell_1.2_read.html">SHELL: 1.2 read</a>
            </li>
            <li>
              <a href="/cryptography/basic/openssl_1.3.1_usage.html">openssl 1.3.1 SSL DEBUG: s_client</a>
            </li>
            <li>
              <a href="/linux/advance/network_theory-TCP-IP-note.html">网络: 理论 - TCP/IP详解读书笔记</a>
            </li>
            <li>
              <a href="/service/apache/1.0.1_apache_work_mode.html">apache: 理论 - 工作模式</a>
            </li>
            <li>
              <a href="/linux/advance/memory_03_general_memory_layout.html">内存: 进程内存布局 - 堆栈</a>
            </li>
          </ul>

		<h3>文章分类</h3>
		  <ul>

            <li>
              <a href="/android/index.html">android</a>
            </li>
            <li>
              <a href="/bigdata/index.html">bigdata</a>
            </li>
            <li>
              <a href="/blockchain/index.html">blockchain</a>
            </li>
            <li>
              <a href="/blog/index.html">blog</a>
            </li>
            <li>
              <a href="/cloud/index.html">cloud</a>
            </li>
            <li>
              <a href="/cryptography/index.html">cryptography</a>
            </li>
            <li>
              <a href="/database/index.html">database</a>
            </li>
            <li>
              <a href="/devops/index.html">devops</a>
            </li>
            <li>
              <a href="/go/index.html">go</a>
            </li>
            <li>
              <a href="/ios/index.html">ios</a>
            </li>
            <li>
              <a href="/java/index.html">java</a>
            </li>
            <li>
              <a href="/linux/index.html">linux</a>
            </li>
            <li>
              <a href="/python/index.html">python</a>
            </li>
            <li>
              <a href="/service/index.html">service</a>
            </li>
            <li>
              <a href="/virtualization/index.html">virtualization</a>
            </li>
            <li>
              <a href="/web/index.html">web</a>
            </li>
          </ul>

      </div>
    </div>

    <div class="col-lg-7 col-md-7 col-sm-7">

        <div class="article-summary">
        <div class="article-title">
          <a href="linux/shell/shell_1.2_read.html">SHELL: 1.2 read</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>21 Sep 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h3>0. read简介</h3>

<p>read是将标准输入中读取逻辑行，然后将其转换成一个或多个变量的工具。一般是从文件中读取内容，然后赋值给shell脚本的变量。</p>

<h3>1. read变量和选项</h3>

<p>变量：</p>

<ul>
<li><code>IFS</code>: 逻辑行中用于分隔不同field的分隔符</li>
</ul>

<blockquote>
<p>其他变量参见 <a href="https://man7.org/linux/man-pages/man1/read.1p.html">read manual</a></p>
</blockquote>

<p>选项：</p>

<ul>
<li><code>-r</code>: 把转义符<code>\</code>当做普通字符。</li>
</ul>

<h3>2. 实例：读取配置文件</h3>

<p>配置文件内容：<code>var.conf</code></p>
<pre class="chroma">cat <span class="s">&lt;&lt; EOF &gt; var.conf
</span><span class="s">id=01
</span><span class="s">type=apple
</span><span class="s">EOF</span>
</pre>
<p>读取配置的shell脚本：<code>load_var.sh</code></p>
<pre class="chroma"><span class="cp">#!/bin/bash
</span><span class="cp"></span>
<span class="c1"># read content from conf file and transfer it to var value pair in shell script</span>
#
<span class="c1"># EXAMPLE:</span>
#
<span class="c1"># var.conf&#39;s content</span>
<span class="c1"># ==================================</span>
<span class="c1"># id=01</span>
<span class="c1"># type=apple</span>
<span class="c1"># ==================================</span>
#
<span class="c1"># this script will read one line each time,</span>
<span class="c1"># for example the first line &#34;id=01&#34;, and</span>
<span class="c1"># separate it by &#34;=&#34;, load the two part to</span>
<span class="c1"># var key and value:</span> 
<span class="c1">#     key=id; value=01</span>
<span class="c1"># then transfer it to new var pair in script</span>
<span class="c1">#     id=01</span>

<span class="nb">set</span> -e

<span class="k">while</span> <span class="nv">IFS</span><span class="o">=</span><span class="s1">&#39;=&#39;</span> <span class="nb">read</span> -r key value
<span class="k">do</span>
    <span class="c1"># ensure key and value is not empty</span>
    <span class="k">if</span> <span class="o">[</span><span class="o">[</span> -z <span class="si">${</span><span class="nv">key</span><span class="si">}</span> <span class="o">]</span><span class="o">]</span> <span class="o">||</span> <span class="o">[</span><span class="o">[</span> -z <span class="si">${</span><span class="nv">value</span><span class="si">}</span> <span class="o">]</span><span class="o">]</span><span class="p">;</span> <span class="k">then</span>
        <span class="k">continue</span>
    <span class="k">fi</span>

    <span class="c1"># assign the content of var value to var which name is the content of var key</span> 
    <span class="c1"># EXAMPLE:</span>
    <span class="c1">#     orinal vars: key=foo; value=bar</span>
    <span class="c1">#     new var:     foo=bar</span>
    <span class="k">if</span> <span class="o">[</span><span class="o">[</span> <span class="si">${</span><span class="nv">key</span><span class="si">}</span> <span class="o">=</span><span class="o">=</span> <span class="s2">&#34;id&#34;</span> <span class="o">]</span><span class="o">]</span> <span class="o">||</span> <span class="o">[</span><span class="o">[</span> <span class="si">${</span><span class="nv">key</span><span class="si">}</span> <span class="o">=</span><span class="o">=</span> <span class="s2">&#34;type&#34;</span> <span class="o">]</span><span class="o">]</span><span class="p">;</span> <span class="k">then</span>
        <span class="nb">eval</span> <span class="s2">&#34;</span><span class="nv">$key</span><span class="s2">=</span><span class="nv">$value</span><span class="s2">&#34;</span>
    <span class="k">fi</span>
<span class="k">done</span> &lt; ./var.conf

<span class="nb">printf</span> <span class="s2">&#34;  id = %s\ntype = %s\n&#34;</span> <span class="si">${</span><span class="nv">id</span><span class="si">}</span> <span class="si">${</span><span class="nv">type</span><span class="si">}</span>
</pre>
<p>执行后的输出演示</p>
<pre class="chroma">sh load_var.sh
  <span class="nv">id</span> <span class="o">=</span> <span class="m">01</span>
<span class="nb">type</span> <span class="o">=</span> apple
</pre>
        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="cryptography/basic/openssl_1.3.1_usage.html">openssl 1.3.1 SSL DEBUG: s_client</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>09 Sep 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>1. s_client</h2>

<p>简介：SSL/TLS 客户端程序，用于调试和SSL服务器的连接。</p>
<pre class="chroma">openssl s_client [-connect host:port] [-servername name] [-verify depth] [-verify_return_error] [-cert filename] [-certform DER|PEM] [-key filename] [-keyform DER|PEM] [-pass arg] [-CApath directory] [-CAfile filename] [-no_alt_chains] [-reconnect] [-pause] [-showcerts] [-debug] [-msg] [-nbio_test] [-state] [-nbio] [-crlf] [-ign_eof] [-no_ign_eof] [-quiet] [-ssl2] [-ssl3] [-tls1] [-no_ssl2] [-no_ssl3] [-no_tls1] [-no_tls1_1] [-no_tls1_2] [-fallback_scsv] [-bugs] [-sigalgs sigalglist] [-curves curvelist] [-cipher cipherlist] [-serverpref] [-starttls protocol] [-engine id] [-tlsextdebug] [-no_ticket] [-sess_out filename] [-sess_in filename] [-rand file(s)] [-serverinfo types] [-status] [-alpn protocols] [-nextprotoneg protocols]
</pre>
<p><strong>选项介绍：</strong></p>

<ul>
<li><code>-connect host:port</code>: 指定连接主机和端口</li>
<li><code>-servername name</code>: TLS SNI (Server Name Indication)</li>
<li><code>-cert certname</code>: 客户端证书（如果使用双向认证的话）</li>
<li><code>-certform format</code>: 客户端证书格式，<code>DER,PEM</code>，默认值<code>PEM</code></li>
<li><code>-key keyfile</code>: 客户端私钥（如果使用双向认证的话）</li>
<li><code>-keyform format</code>: 客户端私钥格式，<code>DER,PEM</code>，默认值<code>PEM</code></li>
<li><code>-pass arg</code>: 客户端私钥密码</li>
<li><code>-tls1,-tls1_1,-tls1_2,-no_ssl2,-no_ssl3,-no_tls1,-no_tls1_1,-no_tls1_2</code>: 指定<code>ssl protocol</code></li>
<li><code>-cipher cipherlist</code>: 指定ssl连接的加密算法</li>
</ul>

<blockquote>
<p>加密算法详情见：<a href="https://www.openssl.org/docs/man1.0.2/man1/ciphers.html">ciphers</a></p>

<p>openssl ssl debug工具详细用法：<a href="https://www.openssl.org/docs/man1.0.2/man1/openssl-s_client.html">openssl s_client</a></p>
</blockquote>

<h2>2. s_client示例</h2>
<pre class="chroma">openssl s_client -cert client.crt -key client.key -tls1_2 -connect 127.0.0.1:80 -servername www.test.com
</pre>
<p>常见的使用场景：</p>

<ul>
<li>debug服务器是否开启了ssl的特定版本；</li>
<li>debug特定的ssl加密算法；</li>
</ul>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="linux/advance/network_theory-TCP-IP-note.html">网络: 理论 - TCP/IP详解读书笔记</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>18 Aug 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h1>一、概述</h1>

<h2>1. 分层</h2>

<p>网络协议通常针对不同层次分别开发，每一层分别负责不同的通信功能。TCP/IP是一个协议族，是不同层次的协议的组合。TCP/IP通常被认为是一个四层协议系统。</p>

<ul>
<li>应用层，telnet、ftp、email</li>
<li>运输层，tcp、udp</li>
<li>网络层，ip、icmp、igmp</li>
<li>链路层，设备驱动程序及接口卡</li>
</ul>

<blockquote>
<p>通常应用层是运行在linux的用户空间，而其他三层是运行在linux的内核空间。</p>

<p>网桥和路由器</p>

<ul>
<li>网桥是在链路层上对网络进行互联，网桥使得多个局域网组合在一起，对于上层来说就好像是一个局域网。</li>
<li>路由器是在网络层上对网络进行互联，TCP/IP倾向于使用路由器而不是网桥来连接网络。</li>
</ul>
</blockquote>

<h2>2. 用途</h2>

<p>TCP/IP中，网络层和运输层的区别最为关键：网络层（IP）提供点对点的服务，而运输层（TCP和UDP）提供端对端的服务。</p>

<p>互联网是网络的网络，通过IP把网络连接起来，端口号用来标识互相通信的应用程序。</p>

<h1>二、链路层</h1>

<h2>1. 回环网络</h2>

<p>对于回环网络的实现，并不会省略传输层和网络层的传输过程，大多数的产品还是照样完成传输层和网络层的所有过程，只是当IP数据报离开网络层时把它返回给自己。</p>

<p><img src="/static/images/docs/linux/advance/network-theory-tcp-ip.png" alt="" /></p>

<p>上图的关键点：</p>

<ul>
<li>传给回环网络（127.0.0.1）的任何数据都作为ip输入</li>
<li>传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上。这是因为广播传送和多播传送的定义（第12章）包含主机本身。</li>
<li>任何传给该主机I P地址的数据均送到环回接口。</li>
</ul>

<p>看上去回环网络的实现中又走了一遍传输层和网络层效率不高。但是这样是简化了设计，相当于把回环网络当成了网络层下面的一个链路层。网络层把一份数据报传送给环回接口，就像传给其他链路层一样，只不过环回接口把它返回到IP的输入队列中。</p>

<blockquote>
<p>虽然回环网络会走一遍传输层和网络层的过程，但是回环网络的包不会出现在网络中。</p>
</blockquote>

<h2>2. MTU 最大传输单元</h2>

<p>如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大，那么IP层就需要进行分片，把数据报分成若干片，这样每一片都小于MTU。</p>

<p><strong>查看linux系统中网卡设备的MTU</strong></p>
<pre class="chroma">netstat -in
Kernel Interface table
Iface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg
eth0             <span class="m">1500</span>     <span class="m">2975</span>      <span class="m">0</span>      <span class="m">0</span> <span class="m">0</span>          <span class="m">1329</span>      <span class="m">0</span>      <span class="m">0</span>      <span class="m">0</span> BMRU
lo              <span class="m">65536</span>        <span class="m">0</span>      <span class="m">0</span>      <span class="m">0</span> <span class="m">0</span>             <span class="m">0</span>      <span class="m">0</span>      <span class="m">0</span>      <span class="m">0</span> LRU
</pre>
<h3>2.1 路径MTU</h3>

<p>在同一个网络中的两台主机进行通信时，该网络的MTU是非常重要的。但是如果是不同网络中的两台主机进行通信时，那么重要的就不在是两台主机各自所在网络的MTU，而是两台主机中间路径上经过的最小MTU。这被称为路径MTU。</p>

<p>但是路径MTU不一定是一个常数，因为这取决于网络路由的路径。而路由的选择不一定是对称的，A到B和B到A不一定是一致的，因此路径MTU在这两个方向上也不一定是一致的。</p>

<p>这里就牵扯到一个重要的问题，路径MTU发现机制，这个机制有点复杂，后面会讨论。</p>

<h1>三、IP: 网际协议</h1>

<h2>1. 引言</h2>

<p>IP是TCP/IP协议族中最核心的协议。所有的TCP、UDP、ICMP和IGMP都以IP数据报格式传输。</p>

<ul>
<li><strong>不可靠</strong>，意思是不保证IP数据报能成功的到达目的地，如果发生某种错误，例如一个路由器的缓冲区用完了，IP有一个简单的处理算法，丢弃该数据报，然后发送ICMP给信源端。任何<strong>可靠性</strong>的需求必须由上层协议来完成，比如说TCP。</li>
<li><strong>无连接</strong>，意思是IP不维护任何关于后续数据报的状态信息。每个数据报的传输都是独立的。这代表如果两个连续发送的数据报，有可能因为路由选择不同，导致后发送的数据报先到达。</li>
</ul>

<h2>2. IP首部</h2>

<p><img src="/static/images/docs/linux/advance/network-theory-tcp-ip-01.png" alt="" /></p>

<p>普通的IP首部有20个字节长，除非含有选项字段。</p>

<p>最高位在左边，记为0bit，最低位在右边，记为31bit。4个字节，32个bit的传输顺序为，首先为0-7bit，其次为8-15bit，然后是16-23bit，最后是24-31bit。这种传输方式被称为big endian字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称之为网络字节序。以其他形式储存二进制整数的机器，比如little endian格式，则必须在传输数据之前把首部转换成网络字节序。</p>

<p>目前的协议版本号是4，因此IP也被称为IPv4。</p>

<p>首部长度指的是首部占32bit字的数目，包括任何选项。由于它是一个4字节（图中的宽度）字段，因此首部最长为60个字节。普通IP数据报（没有任何选项）字段的值是5。</p>

<p>服务类型（TOS）字段包括</p>

<ul>
<li>一个3bit的优先权子字段（现在已被忽略）</li>
<li>4bit的TOS子字段

<ul>
<li>最小时延</li>
<li>最大吞吐量</li>
<li>最高可靠性</li>
<li>最小费用</li>
</ul></li>
<li>1bit的未用位，目前必须设定为0</li>
</ul>

<blockquote>
<p>4bit的TOS子字段，如果全部设定为0，那就意味着是一般服务。</p>

<p>RFC <sup>1340</sup>&frasl;<sub>1349</sub> 详细的描述了如何设定TOS和描述了TOS特性。</p>
</blockquote>

<p>下图列出了对不同应用建议的TOS值。最后一列中给出来的是十六进制值。
<img src="/static/images/docs/linux/advance/network-theory-tcp-ip-02.png" alt="" /></p>

<p>总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度字段和总长度字段，就可以知道IP数据报中的数据内容的起始位置和长度。最长是65535字节。</p>

<p>总长度字段是IP首部中必要的内容。因为有一些数据链路（如以太网）需要填充一些数据以达到小长度。以太网的最小帧是46字节。</p>

<p>标识字段唯一的标识主机发送的每一份数据报。通常每发送一份报文，它的数值就会加1。</p>

<p>TTL（time to live）生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。其初始值由源主机设定（32或64），一旦经过一个处理它的路由器，它的值就减1。当该字段为0时，该报文会被抛弃，并发送ICMP报文通知源主机。</p>

<p>根据协议字段可以判断是哪个协议向IP传送数据。</p>

<p>首部校验和字段是根据IP首部计算的校验和码。</p>

<p>每一份IP数据报文都包含源地址和目的地址。</p>

<p>最后一个字段是任选项，是数据报中可变长的可选信息。这些选项很少被使用，并非所有的主机和路由器支持这些字段。选项字段一直都是以32bit为边界，不足的地方以0补齐。这样就保证了所有的IP首部都是32bit的整数倍。</p>

<h2>3. IP路由选择</h2>

<p>IP的路由非常简单，如果两个主机直接点对点或者在同一个本地网络中（以太网或令牌网），那么IP数据报就直接发送到目的主机上。否则，主机把数据发给默认的路由器上，由路由器来转发该数据报。</p>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="service/apache/1.0.1_apache_work_mode.html">apache: 理论 - 工作模式</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>10 Aug 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>0. 环境背景</h2>

<p>apache httpd version 2.4.54</p>

<h2>1. apache HTTP 的MPMs</h2>

<p>apache HTTP被设计为一个可以在不同环境下工作在不同平台的强大且灵活的web服务器。不同环境和不同平台通常需要不同的特性，或者同一个特性需要不同的实现方式。apache HTTP通过模块化的设计特点充分的满足了不同的场景的需求。</p>

<p>apache HTTP 2.0将这个模块化的设计延展到了它本身作为一个web服务器最基础的功能上。它创建了一个特殊模块，MPMs(Multi-Processing Moudles)，其负责网络端口监听、接收请求和分发请求给子进程。</p>

<p>通过在基础功能上的模块化，得到了如下好处</p>

<ul>
<li>apache HTTP能更优雅，更高效的支持更多不同的操作系统平台。比如说，apache HTTP windows版本的mpm_winnt能使用原生的网络特性。</li>
<li>apache HTTP能更灵活的被定制。比如说，需要可靠性和兼容性的，可以用prefork；需要更高伸缩性的站点，可以用worker或event。</li>
</ul>

<p>在用户视角，MPMs和其他的普通模块没有什么不同，但是不同的是，MPMs同时只能加载一个。</p>

<p>在类UNIX系统平台上，只有三种MPM可选，prefork、worker和event。</p>

<blockquote>
<ul>
<li>当服务器不支持线程，也支持线程安全时，MPMs默认是prefork</li>
<li>当服务器支持线程，但不支持线程安全时，MPMs默认是woker</li>
<li>当服务器支持线程，也支持线程安全时，MPMs默认是event</li>
</ul>
</blockquote>

<h3>1.1 <code>prefork</code></h3>

<p><code>prefork</code>使用多个子进程，每个子进程只有一个线程。每个进程在某个确定的时间只能维持一个连接，效率高，但内存占用量比较大。</p>

<p>这个非线程型的、预派生的web服务器，它适合于没有线程安全库，需要避免线程兼容性问题的系统。它是要求将每个请求相互独立的情况下最好的MPM，这种模式下，一个请求出现问题不会影响到其他请求。</p>

<h4><strong>配置重点</strong></h4>

<p><code>prefork</code>这种MPM能很好的自我调节，所以需要很少的配置。重点是<code>MaxRequestWorkers</code>要设置的足够大，可以处理足够多的请求，同时需要设置的足够小，至少保证可以给所有的进程分配足够的物理内存。</p>

<h4><strong>工作原理</strong></h4>

<p>一个控制进程作为父进程来启动多个子进程，每个子进程负责监听请求连接并处理请求。</p>

<p>apache HTTP会通过相关配置(<code>StartServers</code>,<code>MinSpareServers</code>,<code>MaxSpareServers</code>,<code>MaxRequestWorkers</code>)动态调整进程数量，以保留足够的空闲进程来随时响应请求。</p>

<p>当需要同时处理超过256个请求时，可以调大<code>MaxRequestWorkers</code>和<code>ServerLimit</code>来增强请求处理能力；当服务器内存紧张时，可以调小<code>MaxRequestWorkers</code>来节省内存。</p>

<p><code>MaxConnectionsPerChild</code>配置了一个子进程能处理的最大请求数，超过这个数目，该子进程就会停止处理新请求，然后被杀掉，重新创建一个新的子进程（为了有效的避免内存泄漏）。</p>

<h3>1.2 <code>worker</code></h3>

<p><code>worker</code>使用多个子进程，每个子进程有多个线程，每个线程在某个确定的时间只能维持一个连接，内存占用量比较小，适合高流量的http服务器。缺点是假如一个线程崩溃，整个进程就会连同其任何线程一起&rdquo;死掉&rdquo;，所以要保证一个进程在运行时必须被系统识别为&rdquo;每个线程都是安全的&rdquo;。</p>

<p>这个支持混合多线程多进程的web服务器，由于使用线程来处理请求，所以可以处理海量请求，而系统资源的开销小于基于进程的MPM。但是它也使用了多进程，每个进程又有多个线程，以获得基于进程的稳定性。</p>

<h4><strong>配置重点</strong></h4>

<p><code>worker</code> MPM，使用<code>ThreadsPerChild</code>来指定每个子进程的线程数量上限，使用<code>MaxRequestWorkers</code>来指定所有进程的线程数量总和上限。</p>

<h4><strong>工作原理</strong></h4>

<p>一个控制进程作为父进程来启动多个子进程，每个子进程创建固定数量的处理请求的线程以及一个监听线程，监听线程会监听请求连接，并将它们转交给处理请求的线程来处理。</p>

<p>apache HTTP 会通过相关配置(<code>MinSpareThreads</code>,<code>MaxSpareThreads</code>)来动态调整线程和进程数量，以保留足够的空闲线程来随时响应请求。</p>

<p>使用<code>worker</code> MPM时，最大处理的连接请求数量由<code>MaxRequestWorkers</code>限定；最大子进程数量由<code>MaxRequestWorkers</code>除以<code>ThreadsPerChild</code>的值来限定。</p>

<p>另外，有两个单独的配置来决定子进程和子进程中线程的绝对上限，这个配置只能完全停止apache HTTP进程，然后再启动才可以更改。其中<code>ServerLimit</code>是子进程的绝对上限值，必须要大于或等于<code>MaxRequestWorkers</code>除以<code>ThreadsPerChild</code>的值。<code>ThreadLimit</code>是子进程中线程的绝对上限值，必须要大于或者等于<code>ThreadsPerChild</code>。</p>

<blockquote>
<p>需要额外注意的是，apache HTTP的子进程包含活动进程和正在关闭中的进程，至少会有一个进程来提供服务，至多有<code>MaxRequestWorkers</code>个正在关闭的进程（实际数量肯定少于这个值）。这种行为的产生原因有两种情况，一种是因为<code>MaxConnectionsPerChild</code>配置了一个子进程能处理的最大请求数，超过这个数目，该子进程就会停止处理新请求，然后被杀掉，重新创建一个新的子进程（为了有效的避免内存泄漏）。另外一种是因为空闲线程的数量超过了<code>MaxSpareThreads</code>配置的数目，触发了自动调节机制。如果希望关闭这种行为，可以将<code>MaxConnectionsPerChild</code>设置为0，然后将<code>MaxSpareThreads</code>和<code>MaxRequestWorkers</code>设置为同样的值。</p>
</blockquote>

<h3>1.3 <code>event</code></h3>

<p><code>event</code> MPM旨在通过将一些处理工作传递给侦听器线程从而释放工作线程以服务新请求的方式，来允许同时处理更多请求。</p>

<h4><strong>与<code>worker</code>的关系</strong></h4>

<p><code>event</code>是基于<code>worker</code>的。一个控制进程作为父进程来启动子进程，每个子进程创建固定数量的处理请求的线程以及一个监听线程，监听线程会监听请求连接，并将它们转交给处理请求的线程来处理。</p>

<h4><strong>配置重点</strong></h4>

<p><code>event</code>与<code>worker</code>配置基本一致，只是多了<code>AsyncRequestWorkerFactor</code>。</p>

<h4><strong>工作原理</strong></h4>

<p><code>event</code> MPM致力于在HTTP中的keepalive问题。</p>

<p>在客户端完成第一次请求后，它可以保留当前的连接而不关闭它，在相同的连接上发送接下来的请求，从而节省了TCP连接的信号交换成本。然而apache HTTP会留出一个完整的进程/线程来等待客户端的请求，这样相当于将其闲置，只为等待。为了解决这个问题，<code>event</code> MPM在每个子进程中使用指定的监听线程来掌控所有的监听sockets、所有处于Keepalive状态的sockets、处理程序和协议过滤器完成工作的sockets和唯一剩下发送给客户端的sockets。</p>

<p>这种新架构，使用了非阻塞sockets和APR提供的现代内核特性（比如linux的epoll）。
单个进程/线程块可以处理的连接总数由<code>AsyncRequestWorkerFactor</code>配置限定。</p>

<blockquote>
<p>更多event相关的原理，可详细参照<a href="https://httpd.apache.org/docs/2.4/mod/event.html">apache httpd event</a>。实践总结apahce(event) &lt;= nginx + apache(worker)，<code>event</code>唯一的作用是比<code>worker</code>节省资源，可以用更少的线程处理同样多的请求（超过线程能力的连接被放到队列中）。</p>
</blockquote>

<h2>2. MPM配置</h2>

<h3>2.1 常用MPM配置</h3>
<pre class="chroma"><span class="c1"># prefork MPM</span>
<span class="c1"># StartServers: number of server processes to start</span>
<span class="c1"># MinSpareServers: minimum number of server processes which are kept spare</span>
<span class="c1"># MaxSpareServers: maximum number of server processes which are kept spare</span>
<span class="c1"># MaxRequestWorkers: maximum number of server processes allowed to start</span>
<span class="c1"># MaxConnectionsPerChild: maximum number of connections a server process serves before terminating</span>
&lt;IfModule mpm_prefork_module&gt;
    StartServers             <span class="m">5</span>
    MinSpareServers          <span class="m">5</span>
    MaxSpareServers         <span class="m">10</span>
    MaxRequestWorkers      <span class="m">250</span>
    MaxConnectionsPerChild   <span class="m">0</span>
&lt;/IfModule&gt;

<span class="c1"># worker MPM</span>
<span class="c1"># StartServers: initial number of server processes to start</span>
<span class="c1"># MinSpareThreads: minimum number of worker threads which are kept spare</span>
<span class="c1"># MaxSpareThreads: maximum number of worker threads which are kept spare</span>
<span class="c1"># ThreadsPerChild: constant number of worker threads in each server process</span>
<span class="c1"># MaxRequestWorkers: maximum number of worker threads</span>
<span class="c1"># MaxConnectionsPerChild: maximum number of connections a server process serves before terminating</span>
&lt;IfModule mpm_worker_module&gt;
    StartServers             <span class="m">3</span>
    MinSpareThreads         <span class="m">75</span>
    MaxSpareThreads        <span class="m">250</span> 
    ThreadsPerChild         <span class="m">25</span>
    MaxRequestWorkers      <span class="m">400</span>
    MaxConnectionsPerChild   <span class="m">0</span>
&lt;/IfModule&gt;

<span class="c1"># event MPM</span>
<span class="c1"># StartServers: initial number of server processes to start</span>
<span class="c1"># MinSpareThreads: minimum number of worker threads which are kept spare</span>
<span class="c1"># MaxSpareThreads: maximum number of worker threads which are kept spare</span>
<span class="c1"># ThreadsPerChild: constant number of worker threads in each server process</span>
<span class="c1"># MaxRequestWorkers: maximum number of worker threads</span>
<span class="c1"># MaxConnectionsPerChild: maximum number of connections a server process serves</span>
<span class="c1">#                         before terminating</span>
&lt;IfModule mpm_event_module&gt;
    StartServers             <span class="m">3</span>
    MinSpareThreads         <span class="m">75</span>
    MaxSpareThreads        <span class="m">250</span>
    ThreadsPerChild         <span class="m">25</span>
    MaxRequestWorkers      <span class="m">400</span>
    MaxConnectionsPerChild   <span class="m">0</span>
&lt;/IfModule&gt;
</pre>
<blockquote>
<p><code>MaxRequestWorkers</code> 在 apache HTTP 2.3.13 之前被称为 <code>MaxClients</code>
<code>MaxConnectionsPerChild</code> 在apache HTTP 2.3.9 之前被称为<code>MaxRequestsPerChild</code></p>
</blockquote>

<h3>2.2 配置项详解</h3>

<h4><strong><code>StartServers</code>(event, worker, prefork)</strong></h4>

<p>指定服务器启动时建立的子进程数量。</p>

<p><code>prefork</code>MPM下默认为5。</p>

<p><code>worker</code>和<code>event</code>MPM下默认是3.</p>

<hr />

<h4><strong><code>MinSpareServers</code>(prefork)</strong></h4>

<p>指定空闲子进程的最小数量，默认为5。</p>

<p>如果当前空闲子进程数少于<code>MinSpareServers</code> ，那么Apache将创建一个子进程，一秒后，创建两个，一秒后，创建四个，就这样持续增加，最大一次创建32个。就这样创建进程直到达到<code>MinSpareServers</code>指定的数值。</p>

<hr />

<h4><strong><code>MaxSpareServers</code>(prefork)</strong></h4>

<p>设置空闲子进程的最大数量，默认为10。</p>

<p>如果当前有超过<code>MaxSpareServers</code>数量的空闲子进程，那么父进程将杀死多余的子进程。此参数不要设的太大。如果你将该指令的值设置为等于或小于<code>MinSpareServers</code>，Apache将会自动将其修改成<code>MinSpareServers+1</code>。</p>

<hr />

<h4><strong><code>MinSpareThreads</code>(event, worker)</strong></h4>

<p>指定空闲子线程的最小数量，默认为75。</p>

<p><code>worker</code>和<code>event</code>在服务级别来处理空闲子线程，当空闲子线程小于最小值，Apache会创建子进程，直到空闲子线程大于<code>MaxSpareThreads</code>。</p>

<hr />

<h4><strong><code>MaxSpareThreads</code>(event, worker)</strong></h4>

<p>指定空闲子线程的最大数量，默认为250。</p>

<p><code>worker</code>和<code>event</code>在服务级别来处理空闲子线程，当空闲子线程超过了最大值，Apache会杀死子进程，直到空闲子线程小于<code>MaxSpareThreads</code>。</p>

<hr />

<h4><strong><code>ThreadsPerChild</code>(event, worker)</strong></h4>

<p>指定每个子进程要创建多少个子线程，默认为25。</p>

<p><code>ThreadsPerChild</code>不可以超过<code>ThreadLimit</code>。</p>

<hr />

<h4><strong><code>MaxRequestWorkers</code>(event, worker, prefork)</strong></h4>

<p>指定同一时间客户端最大接入请求的数量。</p>

<p><code>prefork</code>MPM下，默认为256。任何超过<code>MaxRequestWorkers</code>限制的请求都将进入等候队列，一旦一个链接被释放，队列中的请求将得到服务。要增大这个值，你必须同时增大<code>ServerLimit</code>。</p>

<p><code>worker</code>和<code>event</code>MPM下，默认为<code>16(ServerLimit)*25(ThreadsPerChild)</code>。如果<code>MaxRequestWorkers</code>和<code>ThreadsPerChild</code>需要的子进程数超过16，同时应该提高<code>ServerLimit</code>。</p>

<hr />

<h4><strong><code>MaxConnectionsPerChild</code>(event, worker, prefork)</strong></h4>

<p>每个子进程在其生存期内允许处理的最大请求数量，默认为0，即子进程永远不会结束。</p>

<p>到达MaxRequestsPerChild的限制后，子进程将会结束。将MaxRequestsPerChild设置成非零值有两个好处：</p>

<ol>
<li>可以防止(偶然的)内存泄漏无限进行，从而耗尽内存。</li>
<li>给进程一个有限寿命，从而有助于当服务器负载减轻的时候减少活动进程的数量。</li>
</ol>

<hr />

<h4><strong><code>ServerLimit</code>(event, worker, prefork)</strong></h4>

<p>在<code>prefork</code>MPM下，指定Apache httpd 进程声明周期内<code>MaxRequestWorkers</code>可配置的最大值。</p>

<p>在<code>worker</code>和<code>event</code>MPM下，和<code>ThreadLimit</code>组合在一起，指定Apache httpd 进程声明周期内<code>MaxRequestWorkers</code>可配置的最大值。</p>

<p>需要重点关注的是，当设定远超过需要的值时，未使用的额外的共享内存也会被分配占用。如果<code>ServerLimit</code>和<code>MaxRequestWorkers</code>设定为超过系统可以支撑的值时，Apache httpd不会启动或者会不稳定。</p>

<p>在<code>prefork</code>MPM下，只有当<code>MaxRequestWorkers</code>需要设定超过其默认值（256）时，才需要设定<code>ServerLimit</code>。不要将<code>ServerLimit</code>的值设置为高于你可能希望将 <code>MaxRequestWorkers</code> 设置为的值。</p>

<p>在<code>worker</code>和<code>event</code>MPM下，只有当 <code>MaxRequestWorkers</code>/<code>ThreadsPerChild</code>需要大于默认值（16）时，才需要设定<code>ServerLimit</code>。</p>

<blockquote>
<p><code>ServerLimit</code>(prefork)在编译阶段，默认有个最大配置限制200000。如果希望可以配置的更大，则必须修改mpm源码中的<code>MAX_SERVER_LIMIT</code>，然后重新编译apache。</p>
</blockquote>

<hr />

<h4><strong><code>ThreadLimit</code>(event, worker)</strong></h4>

<p>指定 <code>ThreadsPerChild</code>可配置的最大值，默认值64。</p>

<p>需要重点关注的是，当设定远超过需要的值时，为使用的额外的共享内存也会被分配占用。如果<code>ThreadLimit</code>和<code>ThreadsPerChild</code>设定为超过系统可以支撑的值时，Apache httpd不会启动或者会不稳定。</p>

<blockquote>
<p><code>ThreadLimit</code>(worker)在编译阶段，默认有个最大配置限制20000(event 10000)。如果希望可以配置的更大，则必须修改mpm源码中的<code>MAX_THREAD_LIMIT</code>，然后重新编译apache。</p>
</blockquote>

<h2>3. apache模式的查看</h2>

<h3>3.1 常看当前模式</h3>

<p>如果apache已经安装，我们可以用以下命令查看当前模式。</p>
<pre class="chroma">httpd -l
</pre>
<p>若找到 <code>prefork.c</code> 则表示当前工作在<code>prefork</code>MPM，同理出现 <code>worker.c</code> 则工作在<code>worker</code> MPM。</p>

<p>如果apache还未安装，我们在编译的时候可以加入 <code>--with-pem=(prefork|worker)</code> 选项决定启用什么模式。</p>

<h3>3.2 切换模式</h3>
<pre class="chroma"><span class="c1"># a. 将当前的prefork模式启动文件改名</span>
mv httpd httpd.prefork

<span class="c1"># b. 将worker模式的启动文件改名</span>
mv httpd.worker httpd

<span class="c1"># c. 修改Apache配置文件</span>
vi /usr/local/apache2/conf/extra/httpd-mpm.conf
<span class="c1"># 找到里边的如下一段，可适当修改负载等参数：</span>
<span class="c1">#&lt;IfModule mpm_worker_module&gt;</span>
<span class="c1">#StartServers</span> 
<span class="c1">#MaxClients</span> 
<span class="c1">#MinSpareThreads</span> 
<span class="c1">#MaxSpareThreads</span> 
<span class="c1">#ThreadsPerChild</span> 
<span class="c1">#MaxRequestsPerChild</span> 
<span class="c1">#&lt;/IfModule&gt;</span>

<span class="c1"># d. 重新启动服务</span>
/usr/local/apache2/bin/apachectl restart
</pre>
<h2>4. 总结</h2>

<h3>4.1 为什么event和nginx都是用了epoll的原理，但是apache性能不如nginx呢？</h3>

<p>这是因为apache(event)的thread依赖kernel进行调度，有线程的上下文切换成本。但是nginx使用event驱动本身作为调度器，没有上下文切换成本。这也就是为什么<code>nginx+apache(worker)</code>比使用<code>apache(event)</code>更优的原因</p>

<h3>4.2 那么apache和nginx该如何选择呢？</h3>

<ul>
<li>如果是用很重的CGI应用，那么最佳实践是<code>nginx+apache(worker)+CGI</code>；</li>
<li>如果只是静态文件，那么就是<code>nginx</code>；</li>
<li>如果只是做一个proxy，那么就是<code>nginx --proxy-to-&gt; backend</code></li>
</ul>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="linux/advance/memory_03_general_memory_layout.html">内存: 进程内存布局 - 堆栈</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>01 Aug 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h3>0. 进程的常见内存布局(c/c++)</h3>

<p>进程是操作系统分配内存资源的最小单位，每个进程都有自己独立的内存布局（虚拟内存）。包含：</p>

<ul>
<li>stack: 保存function和local var</li>
<li>memory mapping: 保存大块的从文件映射的内存空间，用于加载代码库文件、共享内存等</li>
<li>heap: 程序动态使用的内存</li>
<li>data: 全局变量，分为初始化的(data segment，实际分配内存)和非初始化的(bss segment，实际未分配内存)</li>
<li>text: 保存运行的code</li>
</ul>

<blockquote>
<p>memory mapping的内存会统计在top命令的SHR字段，所以，这个字段统计的内存并不全是共享内存，也包含其他被映射的文件，例如代码库文件</p>
</blockquote>

<p>linux内核给每个进程一个独立的虚拟内存地址。这个虚拟内存的地址是连续的，虚拟内存又分为“用户空间”和“内核空间”。当进程在用户态的时候，只能访问“用户空间”，相反地，只有进程在内核态的时候，才能访问“内核空间”。虽然每个进程的内存空间都包含了“内核空间”，但其实它们是同一段物理内存，这样进程在进入内核态时，都能方便的访问内核态空间内存。</p>

<p>关于“用户空间”，它的结构，一般是从低地址开始依次为text、data、heap、memory mapping。然后stack是从高地址往下分配。
<img src="/static/images/docs/linux/advance/memory_layout.png" alt="" /></p>

<blockquote>
<p>通常情况下，频繁被执行的程序，其text一般是共享并且是只读的。例如gcc、shell、text editor等</p>

<p><a href="https://courses.engr.illinois.edu/cs225/sp2022/resources/stack-heap/">stack and heap</a></p>
</blockquote>

<h3>1. heap和stack的区别</h3>

<ul>
<li>stack由编译器管理，而heap由程序员自己控制，使用方便，但是有泄漏风险。</li>
<li>stack是由虚拟内存地址的高地址向下分配；而heap是由低地址向上分配。</li>
<li>stack的容量由系统预先定义，一般比较小；而heap则是受限于操作系统中有效的虚拟内存，一般比较大。</li>
<li>stack不会产生内存碎片，而heap会产生比较多的碎片。</li>
</ul>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="service/nginx/nginx_2.1.9.03_configuration_log.html">nginx: 配置 - 日志</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>16 May 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>1. 常用的log_format</h2>

<h3>1.1 记录post data</h3>

<p>简单说明就是，在proxy_pass,fastcgi_pass,uwsgi_pass和scgi_pass配置块中，可以使用<code>reqeust_body</code>这个内置变量来获取POST请求的post数据。</p>
<pre class="chroma">log_format logpost &#34;$request_body&#34;;
</pre>
<blockquote>
<p>其他限制见官方文档：<a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body">built in var: request_body</a></p>

<p>注意：当nginx作为web tunnel，客户端使用CONNECT来访问时，使用这个配置无法获取预期值。</p>
</blockquote>

<h3>1.2 记录upstream的响应请求的server地址</h3>
<pre class="chroma">log_format logupstream &#34;$upstream_addr&#34;;
</pre>
<blockquote>
<p><a href="https://nginx.org/en/docs/http/ngx_http_upstream_module.html#var_upstream_addr">module ngx_http_upstream_module var: upstream_addr</a></p>

<p>注意：当nginx作为web tunnel，客户端使用CONNECT来访问时，使用这个配置无法获取预期值。</p>
</blockquote>

<h2>2. 问题</h2>

<h3>2.1 内置的log_format格式</h3>

<p>在nginx.conf中添加如下配置</p>
<pre class="chroma">log_format  combined  &#39;$remote_addr - $remote_user [$time_local] &#39;
                       &#39;&#34;$request&#34; $status $body_bytes_sent &#39;
                       &#39;&#34;$http_referer&#34; &#34;$http_user_agent&#34;&#39;;
</pre>
<p><strong>报错信息</strong></p>
<pre class="chroma">nginx -t
2008/05/26 18:45:16 <span class="o">[</span>emerg<span class="o">]</span> 19875#0: <span class="s2">&#34;log_format&#34;</span> directive duplicate <span class="s2">&#34;log_format&#34;</span> name in /usr/local/nginx/conf/nginx.conf:26
</pre>
<p>大意是，我们重复定义了combined日志格式，但是我仔细检查了整个nginx.conf，以及所有include的配置文件，都没有找到其他的combined这个log_format配置项。</p>

<p><strong>原因解析</strong>
<a href="http://mailman.nginx.org/pipermail/nginx/2008-May/005214.html">nginx邮件列表关于此问题的参考链接</a><br />
原来&rdquo;combined&rdquo; log_format 是在nginx的源码中已经定义过的，我重新去再次定义，实属画蛇添足，当然软件会提示我重复定义了。</p>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="linux/advance/network_tunnel-ipip.html">网络: 隧道 - IPIP</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>12 May 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>0. 隧道技术</h2>

<p>隧道技术是一种通过使用互联网络的基础设施在网络之间传递数据的方式。 使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。 隧道协议将这些其他协议的数据帧或包重新封装在新的包头中发送。 新的包头提供了路由信息，从而使封装的负载数据能够通过互联网络传递。</p>

<h2>1. IPIP</h2>

<h3>1.1 简介</h3>

<p>IPIP是隧道技术中的一种，适合只负载一个IP流的情况。</p>

<h2>2. IPIP实操</h2>

<h3>2.1 环境介绍</h3>

<ul>
<li>系统：fedora 36 aarch64</li>
</ul>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="linux/advance/network_ip-address.html">网络: IP - IP地址简介</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>11 May 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>1. IP地址简介</h2>

<ul>
<li><a href="https://www.iana.org/help/abuse-answers">IANA: Private Use IP</a></li>
<li><a href="https://www.avast.com/c-ip-address-public-vs-private">avast: public ip vs private ip</a></li>
</ul>

<h3>1.1 IP地址类型</h3>

<p>目前有两种IP网段类型，IPV4和IPV6。</p>

<h3>1.2 IP地址格式</h3>

<p>其中IPV4从1983年1月1日开始使用，直至今日依然被广泛使用。IPV4的格式是用&rdquo;.&ldquo;分隔开的四段数字，每段数字的取值范围从0-255，于是IPV4的地址范围从0.0.0.0到255.255.255.255。</p>

<p>而IPV6是从1999年开始部署，IPV6的地址是128位数字，通常使用十六进制字符表示，例如“2001:db8::abc:587”</p>

<h3>1.3 IP地址分配</h3>

<p>IP地址的分配和管理，是以Internet Assigned Numbers Authority (IANA)为中心，其与5个Regional Internet Registries (RIRs)合作来管理。</p>

<p>RIR：</p>

<ul>
<li>AfriNIC (Africa and parts of the Indian Ocean)</li>
<li>APNIC (Asia/Pacific Region)</li>
<li>ARIN (North America and parts of the Caribbean)</li>
<li>LACNIC (Latin America and parts of the Caribbean)</li>
<li>RIPE NCC (Europe, the Middle East and Central Asia)</li>
</ul>

<p>RIR是实际的ip分配机构，它们将ip网段分配给不同的ISP。而IANA则作为一个顶层的注册机构，例如下面这条注册信息</p>
<pre class="chroma">123/8   APNIC   2006-01 whois.apnic.net ALLOCATED
</pre>
<p>这代表了 123.0.0.0 - 123.255.255.255 在2006年1月分配给了APNIC。如果希望知道这个网段中的一段子网段分配给了谁，需要在whois.apnic.net中查询。</p>

<p>IANA只记录以下信息：</p>

<ul>
<li>已分配给 RIR 或其他用户的IP地址</li>
<li>保留用于特殊用途的那些IP地址</li>
<li>那些还没有被分配，留作以后分配和使用的</li>
</ul>

<blockquote>
<ul>
<li>特殊用途的ip地址在IANA显式已经被注册</li>
<li>IANA保留了192.0.32.0 - 192.0.47.255自用</li>
</ul>
</blockquote>

<h2>2. 特殊用途的地址</h2>

<h3>2.1 私有IP地址</h3>

<p>这些私有IP地址，可以被任何人使用，无需任何其他人授权。同时，这些地址也永远不可能在互联网上可见。</p>
<pre class="chroma">10.0.0.0 - 10.255.255.255     (10.0.0.0/8)
172.16.0.0 - 172.31.255.255   (172.16.0.0/12)
192.168.0.0 - 192.168.255.255 (192.168.0.0/16)
</pre>
<blockquote>
<p>由上至下，也被成为ABC三类私有网段。详情见<a href="https://www.rfc-editor.org/rfc/rfc1918.html">RFC1918</a></p>
</blockquote>

<h3>2.2 自动配置的IP地址</h3>
<pre class="chroma">169.254.0.0 - 169.254.255.255
</pre>
<p>用于一个联网设备需要ip地址，却没有被分配静态ip，且无法通过dhcp获取到ip时，自动给这个联网设备分配的一个地址。避免出现网络设备没有ip的情况，但需要注意，这个ip的流量会被限制在本地网络。</p>

<h3>2.3 回环网络IP地址</h3>
<pre class="chroma">127.0.0.0 - 127.255.255.255 (127.0.0.0/8)
</pre>
<p>用于代表设备本身的网络地址，最常用的是127.0.0.1。</p>

<h3>2.4 多播地址</h3>
<pre class="chroma">224.0.0.0 - 239.255.255.255
</pre>
<p>被预留用于在 Internet 中提供多播服务的特殊目的</p>

<h3>2.5 共享地址段</h3>
<pre class="chroma">100.64.0.0/10
</pre>
<p>用于运营商给用户提供的NAT解决方案</p>

<p>其他的还有IANA预留给美国政府机构的地址，详细内容可以查阅<a href="https://www.iana.org/assignments/ipv4-address-space/ipv4-address-space.xml#note1">iana ipv4 ip address space registry</a></p>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="linux/advance/bash_02_00_login_shell_vs_non_login_shell.html">bash: login shell vs non-login shell</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>02 May 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h3>1. login shell和non-login shell是什么？</h3>

<p>login shell是<code>参数0</code>以<code>&quot;-&quot;</code>开头，或者使用<code>--login(-l)</code>选项启动的shell。</p>

<p>non-login shell是除了login shell之外的shell。</p>

<blockquote>
<ul>
<li><a href="https://help.gnome.org/users/gnome-terminal/stable/pref-login-shell.html.en">gnome pages</a></li>
<li><a href="https://linux.die.net/man/1/bash">bash manual docs</a> 查看Invocation部分</li>
</ul>
</blockquote>

<h3>2. 如何区分login shell和non-login shell？</h3>

<p>根据login shell的介绍说明可知，我们可以查看login shell的<code>参数0</code>或根据启动选项中是否包含<code>login</code>来判断</p>
<pre class="chroma"><span class="c1"># METHOD 1，根据参数0是否以&#34;-&#34;开头来判断</span>
<span class="nb">echo</span> <span class="nv">$0</span>
-bash

<span class="c1"># METHOD 2，使用SHELLOPT来判断（这个一定准确，推荐）</span>
<span class="nb">shopt</span> login_shell
login_shell       on

<span class="nb">shopt</span> -q login_shell <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s1">&#39;Login shell&#39;</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s1">&#39;Not login shell&#39;</span>
Login shell
</pre>
<blockquote>
<p>方法1中，参数0不以&rdquo;-&ldquo;开头时，也不一定不是login shell，是因为还有部分是通过&rdquo;&ndash;login&rdquo;选项来启动的。所以推荐用方法2。</p>
</blockquote>

<h3>3. 如何创建login shell和non-login shell？</h3>

<p><strong>创建login shell</strong></p>

<ul>
<li>通过本地或者远程的连接，使用用户名和密码登录获得的第一个shell</li>
<li>通过<code>bash</code>或<code>sh</code>加上<code>--login(-l)</code>参数启动shell</li>
<li>使用<code>sudo -i</code>或<code>su -</code></li>
</ul>

<p><strong>创建non-login shell</strong></p>

<ul>
<li>未使用账号密码登录，直接使用<code>bash</code>或<code>sh</code>命令，无<code>--login(-l)</code>参数启动shell</li>
<li>crond中创建任务，默认是non-login shell，但是可以通过显式使用<code>bash</code>或<code>sh</code>命令加上<code>--login(-l)</code>参数，例如<code>bash(or sh) -l -c &quot;command&quot;</code>来创建login-shell。</li>
</ul>

<blockquote>
<p>这里暂时不讨论图形界面</p>
</blockquote>

<h3>4. 为什么需要有login shell和non-login shell？</h3>

<p>没有找到确切的原因，但是根据网上的讨论，一个相对靠谱的说法是，因为login shell和non-login shell加载的start up文件不同（详细的看man文档），有些登录时需要执行的任务，如果在每次执行其他子shell的时候都执行一遍，这样任务太重。所以才创建了这种non-login shell，避免每次创建子shell环境都会执行一遍那些任务。</p>

<blockquote>
<p><a href="https://unix.stackexchange.com/questions/324359/why-a-login-shell-over-a-non-login-shell">stackexchange answer</a></p>
</blockquote>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="linux/advance/rlimit_fd_02_commands_to_check_current_status.html">rlimit fd: 状态查看命令</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>01 May 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h3>0. fd(文件描述符)限制的项目说明</h3>

<ul>
<li><strong><code>/proc/sys/fs/file-max</code></strong>是linux内核级别的设定，影响的是linux系统上所有进程可以打开的文件数上限</li>
<li><strong><a href="/linux/advance/rlimit_ulimit_01_introduce.html"><code>ulimit</code></a></strong>是用户或用户组级别，通过PAM登录的login shell，fork出的进程可以打开的文件数上限；</li>
<li><strong><code>/proc/sys/fs/file-nr</code></strong>是系统级别当前打开文件状态</li>
<li><strong><code>/proc/$pid/limits</code></strong>是指定进程的资源限制上限</li>
</ul>

<blockquote>
<p>参考文档:<br />
<a href="https://unix.stackexchange.com/questions/55319/are-limits-conf-values-applied-on-a-per-process-basis">ulimit设定的是每个进程的属性，而不是该用户所有进程的总限制</a><br />
<a href="https://unix.stackexchange.com/questions/447583/ulimit-vs-file-max">ulimit vs file-max</a><br />
<a href="https://stackoverflow.com/questions/6180569/need-to-calculate-optimum-ulimit-and-fs-file-max-values-according-to-my-own-se">如何计算最大文件打开数应该设定多少</a></p>
</blockquote>

<h3>1. 系统级别，文件打开数状态查看</h3>
<pre class="chroma"><span class="c1"># 查看linux内核级别的文件描述符上限</span>
cat /proc/sys/fs/file-max
<span class="m">97984</span>

<span class="c1"># 查看目前系统使用的文件描述符数量</span>
cat /proc/sys/fs/file-nr
<span class="m">512</span> <span class="m">0</span> <span class="m">97984</span>
<span class="c1"># 512   -&gt; 分配并使用的文件描述符数量</span>
<span class="c1"># 0     -&gt; 分配却未使用的文件描述符数量</span>
<span class="c1"># 97984 -&gt; 内核级别的最大文件描述符数量</span>
</pre>
<h3>2. 查看特定进程的最大文件打开数状态</h3>
<pre class="chroma">cat /proc/397/limits <span class="p">|</span> grep <span class="s2">&#34;open files&#34;</span>
Max open files            <span class="m">2048</span>                 <span class="m">2048</span>                 files
</pre>
        </div>

    </div>

  </div>
</body>

<footer>
    <div class="container">
        <div class="row footer-links">
            <div class="col-lg-2 col-sm-2">
                <h3>友情链接</h3>
                <ul>
                    <li><a href="">友链位招租</a></li>
                    <li><a href="">友链位招租</a></li>
                </ul>
            </div>
            <div class="col-lg-2 col-sm-2">
                <h3>没想好</h3>
                <ul>
                    <li><a href="">我爸没想好</a></li>
                    <li><a href="">我哥说我爸没想好</a></li>
                </ul>
            </div>
            <div class="col-lg-2 col-sm-2">
                <h3>Hooray</h3>
                <ul>
                    <li><a href="">Hooray</a></li>
                    <li><a href="">What are we Hooray For?</a></li>
                </ul>
            </div>
            <div class="col-lg-2 col-sm-2">
                <h3>前面的footer太浪了</h3>
                <ul>
                    <li><a href="">就是就是</a></li>
                    <li><a href="">偷偷的表示羡慕</a></li>
                </ul>
            </div>
            <div class="col-lg-4 col-sm-4">
                <h3>网站信息</h3>
                <a class="" href="" target="_blank"></a>
                <a class="" href="" target="_blank"></a>
                <a class="" href="" target="_blank"></a>
                <a class="" href="" target="_blank"></a>
                <div class="fine-print">
                    <p>网战由以下技术支撑</p>
                    <ul>
                        <li>Markdown Processor: <a href="https://github.com/russross/blackfriday/tree/v2">Blackfriday V2</a></li>
                        <li>Renderer Engine: <a href="https://github.com/Depado/bfchroma/">bfchroma</a></li>
                        <li>Syntax Highlighter: <a href="https://github.com/alecthomas/chroma">Chroma</a></li>
                        <li>Coding Language: <a href="https://go.dev/">Golang</a></li>
                        <li>Others: Markdown, HTML, CSS</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</footer>

</html>