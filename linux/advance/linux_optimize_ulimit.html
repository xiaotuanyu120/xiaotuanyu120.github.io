<!DOCTYPE html>
<html lang="zh-cmn">

<head>
    <title>XTY Blog | Linux Ops Docs | SRE | DEVOPS</title>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
    <link rel="stylesheet" href="/static/css/chroma.css">
    <link rel="stylesheet" href="/static/css/main.css">
</head>

<div class="blog-title">
	<div class="container">
		<div class="row">
			<div class="col-lg-12">
				<div>
					<a class="main-title" href="/">XTY的小站</a>
                </div>
                <div>
                    <a class="small-title" href="/">记录技术笔记和技术博客</a>
                </div>
			</div>
		</div>
	</div>
</div>

<body>
  <div class="container">

    <div class="col-lg-4 col-lg-offset-1 col-md-4 col-md-offset-1 col-sm-4 col-sm-offset-1">
	  <div id="sidebar">

		<h3>最新文章</h3>
          <ul>

            <li>
              <a href="/java/jvm/jdk_3.1.0_config_java.security.html">JDK 配置 - java security</a>
            </li>
            <li>
              <a href="/linux/advance/dns_01_dns_problem_analysis.html">DNS解析问题排查实践</a>
            </li>
            <li>
              <a href="/linux/advance/dns_00_how_dns_work_in_linux.html">Linux中的DNS解析是如何工作的</a>
            </li>
            <li>
              <a href="/service/dnsmasq/dnsmasq_01.01_introduction_and_basic.html">dnsmasq基础知识</a>
            </li>
            <li>
              <a href="/linux/advance/memory_01_how_memory_work_in_linux.html">linux中的内存是如何工作的？</a>
            </li>
          </ul>

		<h3>文章分类</h3>
		  <ul>

            <li>
              <a href="/android/index.html">android</a>
            </li>
            <li>
              <a href="/bigdata/index.html">bigdata</a>
            </li>
            <li>
              <a href="/blockchain/index.html">blockchain</a>
            </li>
            <li>
              <a href="/blog/index.html">blog</a>
            </li>
            <li>
              <a href="/cloud/index.html">cloud</a>
            </li>
            <li>
              <a href="/cryptography/index.html">cryptography</a>
            </li>
            <li>
              <a href="/database/index.html">database</a>
            </li>
            <li>
              <a href="/devops/index.html">devops</a>
            </li>
            <li>
              <a href="/go/index.html">go</a>
            </li>
            <li>
              <a href="/ios/index.html">ios</a>
            </li>
            <li>
              <a href="/java/index.html">java</a>
            </li>
            <li>
              <a href="/linux/index.html">linux</a>
              <ul>
                <li>
                  <a href="/linux/advance/index.html">advance</a>
                  <ul>
                    <li><a href="/linux/advance/CENTOS_多网卡+多网关配置.html">CENTOS: 多网卡+多网关配置</a></li>
                    <li><a href="/linux/advance/IPTABLES_按国家防流量.html">IPTABLES: 按国家防流量</a></li>
                    <li><a href="/linux/advance/auditd_1.0.0_basic.html">auditd: linux 审计</a></li>
                    <li><a href="/linux/advance/bash_1.1.0_.bashrc_vs_.bash_profile.html">bash 1.1.0 .bashrc vs .bash_profile</a></li>
                    <li><a href="/linux/advance/centos6_booted_services_optimize.html">centos6 开机服务优化</a></li>
                    <li><a href="/linux/advance/curl_1.1.0_post_usage.html">curl 1.1.0 POST usage</a></li>
                    <li><a href="/linux/advance/discuz管理中心登录的时候闪退.html">discuz管理中心登录的时候闪退</a></li>
                    <li><a href="/linux/advance/disk_1.0.1_xfs_undelete_recovery.html">disk: 1.0.1 xfs 硬盘数据恢复</a></li>
                    <li><a href="/linux/advance/dns_00_how_dns_work_in_linux.html">Linux中的DNS解析是如何工作的</a></li>
                    <li><a href="/linux/advance/dns_01_dns_problem_analysis.html">DNS解析问题排查实践</a></li>
                    <li><a href="/linux/advance/ffmpeg_1.1.0_convert_h265_to_h264.html">ffmpeg: 1.1.0 转换h265为h264</a></li>
                    <li><a href="/linux/advance/firewall_ipset_basic.html">firewall: ipset使用教程</a></li>
                    <li><a href="/linux/advance/firewall_ipset_bitmap_ip_mac.html">firewall: ipset-bitmap:ip,mac</a></li>
                    <li><a href="/linux/advance/firewall_iptables_install_centos7.html">防火墙-Centos7使用iptables</a></li>
                    <li><a href="/linux/advance/glibc_1.1.0_centos6.5_upgrade_2.14.html">glibc 1.1.0 centos6升级到2.14</a></li>
                    <li><a href="/linux/advance/iconv_convert_encode_from_win_2_linux.html">linux: tranfer file from windows to linux, using iconv</a></li>
                    <li><a href="/linux/advance/kernel_1.1.0_tcp_time_wait.html">内核调优: 1.1.0 优化TCP来解决TIME_WAIT状态过多</a></li>
                    <li><a href="/linux/advance/kernel_1.1.1_nf_conntrack_table.html">内核调优: 1.1.1 优化nf_conntrack表来解决tcp包被drop的问题</a></li>
                    <li><a href="/linux/advance/kernel_1.1.2_tcp_time_wait_len_vs_fin_timeout.html">内核调优: 1.1.2 TIMEWAIT销毁时间是否可以通过tcp_fin_timeout优化？</a></li>
                    <li><a href="/linux/advance/kernel_1.1.3_listen_backlog.html">内核参数: 1.1.3 内核listen()中的参数 backlog</a></li>
                    <li><a href="/linux/advance/kernel_1.1.4_cgroup.html">linux内核: 1.1.4 cgroup</a></li>
                    <li><a href="/linux/advance/kernel_1.1.5_enable_module.html">linux内核: 1.1.5 启用模块</a></li>
                    <li><a href="/linux/advance/kernel_1.2.0_system_load_or_cpu_load.html">linux内核: 1.2.0 system load or cpu load</a></li>
                    <li><a href="/linux/advance/linux_optimize_kernel.html">linux: 优化 - 内核</a></li>
                    <li><a href="/linux/advance/linux_optimize_ulimit.html">linux: 系统资源限制 - 文件打开数 - ulimit、systemd</a></li>
                    <li><a href="/linux/advance/linux_optimize_ulimit_error.html">linux: 普通用户无法修改ulimit</a></li>
                    <li><a href="/linux/advance/linux_optimize_ulimit_ext_file_describer.html">linux: ulimit优化 - 扩展文件句柄vs文件描述符</a></li>
                    <li><a href="/linux/advance/linux登录后显示_bash-4.1.html">linux登录后显示_bash-4.1</a></li>
                    <li><a href="/linux/advance/linux知识盲点（数组与拷贝）.html">linux知识盲点（数组与拷贝）</a></li>
                    <li><a href="/linux/advance/memory_01_how_memory_work_in_linux.html">linux中的内存是如何工作的？</a></li>
                    <li><a href="/linux/advance/network_Centos7_no_nic_device.html">network: Centos7 没有可用的网络设备</a></li>
                    <li><a href="/linux/advance/network_centos7-network_error.html">network: Centos7-网络服务错误</a></li>
                    <li><a href="/linux/advance/network_tcp_alive_time_check.html">network: tcp 连接存活时间查询方法</a></li>
                    <li><a href="/linux/advance/network_tcp_handshake.html">network: 理解TCP三次握手和四次挥手</a></li>
                    <li><a href="/linux/advance/network_tcp_keepalive.html">network: tcp keepalive (include versus with http keepalive)</a></li>
                    <li><a href="/linux/advance/network_tcp_tcp_queue.html">network: tcp queue(转载)</a></li>
                    <li><a href="/linux/advance/network_vmware_clone_Centos6.html">network: vmware克隆Centos6后的网络设置</a></li>
                    <li><a href="/linux/advance/nginx_log_combined.html">nginx: log_format combined?</a></li>
                    <li><a href="/linux/advance/openssh_1.0.1_sshd_key_auth_error.html">openssh 1.0.1 sshd 密钥认证错误原因排查</a></li>
                    <li><a href="/linux/advance/oper_1.0_file_and_user_process.html">日常管理: 1.0 查看文件与用户和进程的关联</a></li>
                    <li><a href="/linux/advance/optimize_1.2.0_web.html">调优: 1.2.0 web服务器优化</a></li>
                    <li><a href="/linux/advance/rsync_1.1.0_max_connections.html">rsync 1.1.0 error: max connections reached</a></li>
                    <li><a href="/linux/advance/rsync_1.2.0_chmod_chown.html">rsync 1.2.0 chown chmod</a></li>
                    <li><a href="/linux/advance/selinux_1.0.0_basic.html">selinux 1.0.0 basic</a></li>
                    <li><a href="/linux/advance/selinux_1.0.1_enable_selinux_from_disabled.html">selinux 1.0.1 enable selinux from disabled status</a></li>
                    <li><a href="/linux/advance/selinux_1.0.2_sshd_public_key_lable.html">selinux 1.0.2 lable sshd public key file</a></li>
                    <li><a href="/linux/advance/ssl_generate_key_cfssl.html">ssl: generate key by cfssl</a></li>
                    <li><a href="/linux/advance/sudo_1.1.0_SETENV_NOPASSWD.html">sudo 1.1.0 执行sudo时保持env变量</a></li>
                    <li><a href="/linux/advance/systemd_1.0.0_hook_start_and_stop.html">systemd 1.0.0 同时启动关停多个服务</a></li>
                    <li><a href="/linux/advance/systemd_1.1.0_debug_cmd.html">systemd 1.1.0 排查错误使用的命令</a></li>
                    <li><a href="/linux/advance/systemd_1.2.0_unit_file_load_sequence_and_manual.html">systemd 1.2.0 unit file load sequence and manual</a></li>
                    <li><a href="/linux/advance/systemd_1.3.0_start_pre_and_post.html">systemd 1.3.0 exec pre and post</a></li>
                    <li><a href="/linux/advance/systemd_2.1.0_watchdog_for_tomcat.html">systemd 2.1.0 watchdog of systemd for tomcat</a></li>
                    <li><a href="/linux/advance/systemd_2.1.1_watchdog_for_tomcat_error_of_nonroot_user.html">systemd 2.1.1 watchdog of systemd for tomcat continue: nonroot user problem</a></li>
                    <li><a href="/linux/advance/systeminfo_1.1.0_cpuinfo.html">系统信息：1.1.0 cpuinfo 超线程引起的争吵</a></li>
                    <li><a href="/linux/advance/tools_1.1.0_z_cd.html">工具: 1.1.0 切换目录-z武器</a></li>
                    <li><a href="/linux/advance/what_is_sni.html">what is SNI?</a></li>
                    <li><a href="/linux/advance/隐藏nginxtomcat版本号.html">隐藏nginx tomcat版本号</a></li>
                  </ul>
                </li>
                <li>
                  <a href="/linux/basic/index.html">basic</a>
                </li>
                <li>
                  <a href="/linux/desktop/index.html">desktop</a>
                </li>
                <li>
                  <a href="/linux/service/index.html">service</a>
                </li>
                <li>
                  <a href="/linux/shell/index.html">shell</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="/python/index.html">python</a>
            </li>
            <li>
              <a href="/service/index.html">service</a>
            </li>
            <li>
              <a href="/virtualization/index.html">virtualization</a>
            </li>
            <li>
              <a href="/web/index.html">web</a>
            </li>
          </ul>

      </div>
    </div>

    <div class="col-lg-7 col-md-7 col-sm-7">
      <h2>linux: 系统资源限制 - 文件打开数 - ulimit、systemd</h2>
      <div>
        <hr style="border: 0; border-top: 1px dashed #a2a9b6">
      </div>
      <div class="postDate">
        <p>23 Aug 2016</p>
      </div>
      <div>
        <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
      </div>
<h3>0. linux系统资源限制简介</h3>

<p>linux系统中对系统资源的限制使用<a href="#setrlimit">setrlimit</a>这个系统调用，基于这个系统调用，常见的管理工具有ulimit和systemd（应用于不同场景）。</p>

<h3>1. 文件打开数信息查看</h3>
<pre class="chroma"><span class="c1"># 查看linux内核级别的文件描述符上限</span>
cat /proc/sys/fs/file-max
<span class="m">97984</span>

<span class="c1"># 查看目前系统使用的文件描述符数量</span>
cat /proc/sys/fs/file-nr
<span class="m">512</span> <span class="m">0</span> <span class="m">97984</span>
<span class="c1"># 512   -&gt; 分配并使用的文件描述符数量</span>
<span class="c1"># 0     -&gt; 分配却未使用的文件描述符数量</span>
<span class="c1"># 97984 -&gt; 内核级别的最大文件描述符数量</span>
</pre>
<blockquote>
<p><strong>file-max vs ulimit</strong><br />
<code>file-max</code>是linux内核级别的设定，影响的是linux内核最高可以打开的文件数限制；<br />
<code>ulimit</code>是进程级别的设定，影响的是指定用户启动进程最高可以打开的文件数限制；</p>

<p>参考文档:<br />
<a href="https://unix.stackexchange.com/questions/55319/are-limits-conf-values-applied-on-a-per-process-basis">ulimit设定的是每个进程的属性，而不是该用户所有进程的总限制</a><br />
<a href="https://unix.stackexchange.com/questions/447583/ulimit-vs-file-max">ulimit vs file-max</a><br />
<a href="https://stackoverflow.com/questions/6180569/need-to-calculate-optimum-ulimit-and-fs-file-max-values-according-to-my-own-se">如何计算最大文件打开数应该设定多少</a></p>
</blockquote>

<h3>1. ulimit工具使用说明</h3>

<p>针对的是使用pam登录的用户的资源限制，老的init方式启动的进程也会被这个限制。/etc/security/limits.conf是pam_limits这个模块的配置文件，修改此配置文件之后，用户需要重新登录才会生效。</p>

<p><strong>ulimit命令使用说明</strong></p>
<pre class="chroma"><span class="c1"># 查看所有信息</span>
<span class="nb">ulimit</span> -a
core file size          <span class="o">(</span>blocks, -c<span class="o">)</span> <span class="m">0</span>
data seg size           <span class="o">(</span>kbytes, -d<span class="o">)</span> unlimited
scheduling priority             <span class="o">(</span>-e<span class="o">)</span> <span class="m">0</span>
file size               <span class="o">(</span>blocks, -f<span class="o">)</span> unlimited
pending signals                 <span class="o">(</span>-i<span class="o">)</span> <span class="m">3876</span>
max locked memory       <span class="o">(</span>kbytes, -l<span class="o">)</span> <span class="m">64</span>
max memory size         <span class="o">(</span>kbytes, -m<span class="o">)</span> unlimited
open files                      <span class="o">(</span>-n<span class="o">)</span> <span class="m">1024</span>
pipe size            <span class="o">(</span><span class="m">512</span> bytes, -p<span class="o">)</span> <span class="m">8</span>
POSIX message queues     <span class="o">(</span>bytes, -q<span class="o">)</span> <span class="m">819200</span>
real-time priority              <span class="o">(</span>-r<span class="o">)</span> <span class="m">0</span>
stack size              <span class="o">(</span>kbytes, -s<span class="o">)</span> <span class="m">10240</span>
cpu <span class="nb">time</span>               <span class="o">(</span>seconds, -t<span class="o">)</span> unlimited
max user processes              <span class="o">(</span>-u<span class="o">)</span> <span class="m">3876</span>
virtual memory          <span class="o">(</span>kbytes, -v<span class="o">)</span> unlimited
file locks                      <span class="o">(</span>-x<span class="o">)</span> unlimited

<span class="c1"># 查看针对当前用户的软限制</span>
<span class="nb">ulimit</span> -Sn
<span class="m">1024</span>

<span class="c1"># 查看针对当前用户的硬限制</span>
<span class="nb">ulimit</span> -Hn
<span class="m">1024</span>
</pre>
<p>其中open files对应的配置数目是最大打开文件数目，默认是1024，生产环境下，这个参数会影响到某些程序的并发数量，例如mysql。</p>

<p><strong>ulimit配置文件：limits.conf</strong></p>
<pre class="chroma"><span class="c1"># 修改/etc/security/limits.conf</span>
********************
* soft nofile <span class="m">32768</span>
* hard nofile <span class="m">65535</span>
********************
<span class="c1">## 重点需要注意 ##</span>
<span class="c1"># 后来发现编辑此文件并没有改变ulimit -a 中的open files值，原来是因为，当我们用&#39;*&#39;入口来配置时，会被/etc/security/limits.d/90-nproc.conf中的配置所覆盖，此时只需要去更改此默认值就可以了</span>


<span class="c1"># limits.conf实际是linux pam中的pam_limits.so的配置文件，针对于单个会话</span>
<span class="c1"># 编辑/etc/pam.d/login</span>
********************
session    required     /lib64/security/pam_limits.so
********************
</pre>
<blockquote>
<p>limits.conf的详细说明</p>

<ul>
<li>格式：<code>&lt;domain&gt;        &lt;type&gt;  &lt;item&gt;  &lt;value&gt;</code>

<ul>
<li><domain> can be:</li>
<li>a user name</li>
<li>a group name, with @group syntax</li>
<li>the wildcard *, for default entry</li>
<li>the wildcard %, can be also used with %group syntax, for maxlogin limit</li>
<li><type> can have the two values:</li>
<li>&ldquo;soft&rdquo; for enforcing the soft limits - 取值范围是0-该用户资源上限，普通用户可配置</li>
<li>&ldquo;hard&rdquo; for enforcing hard limits - 设定了该用户资源上限，只有管理员可配置</li>
<li>&rdquo;-&rdquo; for both enforcing hard and soft limits</li>
<li><item> can be one of the following:</li>
<li>core - limits the core file size (KB)</li>
<li>data - max data size (KB)</li>
<li>fsize - maximum filesize (KB)</li>
<li>memlock - max locked-in-memory address space (KB)</li>
<li>nofile - max number of open file descriptors</li>
<li>rss - max resident set size (KB)</li>
<li>stack - max stack size (KB)</li>
<li>cpu - max CPU time (MIN)</li>
<li>nproc - max number of processes</li>
<li>as - address space limit (KB)</li>
<li>maxlogins - max number of logins for this user</li>
<li>maxsyslogins - max number of logins on the system</li>
<li>priority - the priority to run user process with</li>
<li>locks - max number of file locks the user can hold</li>
<li>sigpending - max number of pending signals</li>
<li>msgqueue - max memory used by POSIX message queues (bytes)</li>
<li>nice - max nice priority allowed to raise to values: [-20, 19]</li>
<li>rtprio - max realtime priority</li>
</ul></li>
</ul>
</blockquote>

<h3>2. systemd</h3>

<p>systemd默认会有一个资源分配值，例如文件打开数的默认值是4096。可以通过修改systemd默认资源分配值或者单个unit文件配置资源分配值这两种方式来修改systemd启动的service的资源限制数值。</p>

<ul>
<li><code>/etc/systemd/system.conf</code>：系统进程的默认限制</li>
<li><code>/etc/systemd/user.conf</code>：用户进程的默认限制</li>
</ul>

<h4>1) 修改systemd默认资源分配值</h4>

<p><strong>systemd默认资源限制配置文件：<code>/etc/systemd/system.conf</code></strong></p>
<pre class="chroma">#DefaultLimitCPU=
#DefaultLimitFSIZE=
#DefaultLimitDATA=
#DefaultLimitSTACK=
#DefaultLimitCORE=
#DefaultLimitRSS=
#DefaultLimitNOFILE=
#DefaultLimitAS=
#DefaultLimitNPROC=
#DefaultLimitMEMLOCK=
#DefaultLimitLOCKS=
#DefaultLimitSIGPENDING=
#DefaultLimitMSGQUEUE=
#DefaultLimitNICE=
#DefaultLimitRTPRIO=
#DefaultLimitRTTIME=
</pre>
<p><strong>system.conf重新加载命令</strong></p>
<pre class="chroma">systemctl daemon-reexec
</pre>
<h4>2) 修改systemd unit文件资源分配值</h4>

<p>配置以下项目到unit文件的service配置块中</p>

<table>
<thead>
<tr>
<th>Directive</th>
<th>ulimit equivalent</th>
<th>Unit</th>
</tr>
</thead>

<tbody>
<tr>
<td>LimitCPU=</td>
<td>ulimit -t</td>
<td>Seconds</td>
</tr>

<tr>
<td>LimitFSIZE=</td>
<td>ulimit -f</td>
<td>Bytes</td>
</tr>

<tr>
<td>LimitDATA=</td>
<td>ulimit -d</td>
<td>Bytes</td>
</tr>

<tr>
<td>LimitSTACK=</td>
<td>ulimit -s</td>
<td>Bytes</td>
</tr>

<tr>
<td>LimitCORE=</td>
<td>ulimit -c</td>
<td>Bytes</td>
</tr>

<tr>
<td>LimitRSS=</td>
<td>ulimit -m</td>
<td>Bytes</td>
</tr>

<tr>
<td>LimitNOFILE=</td>
<td>ulimit -n</td>
<td>Number of File Descriptors</td>
</tr>

<tr>
<td>LimitAS=</td>
<td>ulimit -v</td>
<td>Bytes</td>
</tr>

<tr>
<td>LimitNPROC=</td>
<td>ulimit -u</td>
<td>Number of Processes</td>
</tr>

<tr>
<td>LimitMEMLOCK=</td>
<td>ulimit -l</td>
<td>Bytes</td>
</tr>

<tr>
<td>LimitLOCKS=</td>
<td>ulimit -x</td>
<td>Number of Locks</td>
</tr>

<tr>
<td>LimitSIGPENDING=</td>
<td>ulimit -i</td>
<td>Number of Queued Signals</td>
</tr>

<tr>
<td>LimitMSGQUEUE=</td>
<td>ulimit -q</td>
<td>Bytes</td>
</tr>

<tr>
<td>LimitNICE=</td>
<td>ulimit -e</td>
<td>Nice Level</td>
</tr>

<tr>
<td>LimitRTPRIO=</td>
<td>ulimit -r</td>
<td>Realtime Priority</td>
</tr>

<tr>
<td>LimitRTTIME=</td>
<td>No equivalent</td>
<td>Microseconds</td>
</tr>
</tbody>
</table>

<blockquote>
<p><a href="https://www.freedesktop.org/software/systemd/man/systemd.exec.html#Process%20Properties">manual for systemd.exec</a></p>
</blockquote>

<h3>3. podman（cgroup manager: systemd）</h3>

<p>使用podman的rootless模式启动容器时，配置文件是<code>~/.config/containers/containers.conf</code></p>
<pre class="chroma">[containers]
default_ulimits = [
 &#34;nproc=65535:65535&#34;,
 &#34;nofile=65535:65535&#34;,
]
``` 
&gt; 这里设定的值，不可以高于运行容器普通用户的自身资源限定值

## 附录
### setrlimit
</pre>
<p>Name
getrlimit, setrlimit, prlimit - get/set resource limits</p>

<p>Synopsis
#include <sys/time.h>
#include <sys/resource.h></p>

<p>int getrlimit(int resource, struct rlimit *rlim);
int setrlimit(int resource, const struct rlimit *rlim);</p>

<p>int prlimit(pid_t pid, int resource, const struct rlimit *new_limit,
struct rlimit *old_limit);</p>

<p>Feature Test Macro Requirements for glibc (see feature_test_macros(7)):</p>

<p>prlimit(): _GNU_SOURCE &amp;&amp; _FILE_OFFSET_BITS == 64
Description
The getrlimit() and setrlimit() system calls get and set resource limits respectively. Each resource has an associated soft and hard limit, as defined by the rlimit structure:</p>

<p>struct rlimit {</p>
<pre class="chroma">rlim_t rlim_cur;  /* Soft limit */
rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */
</pre>
<p>};
The soft limit is the value that the kernel enforces for the corresponding resource. The hard limit acts as a ceiling for the soft limit: an unprivileged process may only set its soft limit to a value in the range from 0 up to the hard limit, and (irreversibly) lower its hard limit. A privileged process (under Linux: one with the CAP_SYS_RESOURCE capability) may make arbitrary changes to either limit value.
The value RLIM_INFINITY denotes no limit on a resource (both in the structure returned by getrlimit() and in the structure passed to setrlimit()).</p>

<p>The resource argument must be one of:</p>

<p>RLIMIT_AS
The maximum size of the process&rsquo;s virtual memory (address space) in bytes. This limit affects calls to brk(2), mmap(2) and mremap(2), which fail with the error ENOMEM upon exceeding this limit. Also automatic stack expansion will fail (and generate a SIGSEGV that kills the process if no alternate stack has been made available via sigaltstack(2)). Since the value is a long, on machines with a 32-bit long either this limit is at most 2 GiB, or this resource is unlimited.
RLIMIT_CORE
Maximum size of core file. When 0 no core dump files are created. When nonzero, larger dumps are truncated to this size.
RLIMIT_CPU
CPU time limit in seconds. When the process reaches the soft limit, it is sent a SIGXCPU signal. The default action for this signal is to terminate the process. However, the signal can be caught, and the handler can return control to the main program. If the process continues to consume CPU time, it will be sent SIGXCPU once per second until the hard limit is reached, at which time it is sent SIGKILL. (This latter point describes Linux behavior. Implementations vary in how they treat processes which continue to consume CPU time after reaching the soft limit. Portable applications that need to catch this signal should perform an orderly termination upon first receipt of SIGXCPU.)
RLIMIT_DATA
The maximum size of the process&rsquo;s data segment (initialized data, uninitialized data, and heap). This limit affects calls to brk(2) and sbrk(2), which fail with the error ENOMEM upon encountering the soft limit of this resource.
RLIMIT_FSIZE
The maximum size of files that the process may create. Attempts to extend a file beyond this limit result in delivery of a SIGXFSZ signal. By default, this signal terminates a process, but a process can catch this signal instead, in which case the relevant system call (e.g., write(2), truncate(2)) fails with the error EFBIG.
RLIMIT_LOCKS (Early Linux 2.4 only)
A limit on the combined number of flock(2) locks and fcntl(2) leases that this process may establish.
RLIMIT_MEMLOCK
The maximum number of bytes of memory that may be locked into RAM. In effect this limit is rounded down to the nearest multiple of the system page size. This limit affects mlock(2) and mlockall(2) and the mmap(2) MAP_LOCKED operation. Since Linux 2.6.9 it also affects the shmctl(2) SHM_LOCK operation, where it sets a maximum on the total bytes in shared memory segments (see shmget(2)) that may be locked by the real user ID of the calling process. The shmctl(2) SHM_LOCK locks are accounted for separately from the per-process memory locks established by mlock(2), mlockall(2), and mmap(2) MAP_LOCKED; a process can lock bytes up to this limit in each of these two categories. In Linux kernels before 2.6.9, this limit controlled the amount of memory that could be locked by a privileged process. Since Linux 2.6.9, no limits are placed on the amount of memory that a privileged process may lock, and this limit instead governs the amount of memory that an unprivileged process may lock.
RLIMIT_MSGQUEUE (Since Linux 2.6.8)
Specifies the limit on the number of bytes that can be allocated for POSIX message queues for the real user ID of the calling process. This limit is enforced for mq_open(3). Each message queue that the user creates counts (until it is removed) against this limit according to the formula:
bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +</p>
<pre class="chroma">    attr.mq_maxmsg * attr.mq_msgsize
</pre>
<p>where attr is the mq_attr structure specified as the fourth argument to mq_open(3).
The first addend in the formula, which includes sizeof(struct msg_msg *) (4 bytes on Linux/i386), ensures that the user cannot create an unlimited number of zero-length messages (such messages nevertheless each consume some system memory for bookkeeping overhead).</p>

<p>RLIMIT_NICE (since Linux 2.6.12, but see BUGS below)
Specifies a ceiling to which the process&rsquo;s nice value can be raised using setpriority(2) or nice(2). The actual ceiling for the nice value is calculated as 20 - rlim_cur. (This strangeness occurs because negative numbers cannot be specified as resource limit values, since they typically have special meanings. For example, RLIM_INFINITY typically is the same as -1.)
RLIMIT_NOFILE
Specifies a value one greater than the maximum file descriptor number that can be opened by this process. Attempts (open(2), pipe(2), dup(2), etc.) to exceed this limit yield the error EMFILE. (Historically, this limit was named RLIMIT_OFILE on BSD.)
RLIMIT_NPROC
The maximum number of processes (or, more precisely on Linux, threads) that can be created for the real user ID of the calling process. Upon encountering this limit, fork(2) fails with the error EAGAIN.
RLIMIT_RSS
Specifies the limit (in pages) of the process&rsquo;s resident set (the number of virtual pages resident in RAM). This limit only has effect in Linux 2.4.x, x &lt; 30, and there only affects calls to madvise(2) specifying MADV_WILLNEED.
RLIMIT_RTPRIO (Since Linux 2.6.12, but see BUGS)
Specifies a ceiling on the real-time priority that may be set for this process using sched_setscheduler(2) and sched_setparam(2).
RLIMIT_RTTIME (Since Linux 2.6.25)
Specifies a limit (in microseconds) on the amount of CPU time that a process scheduled under a real-time scheduling policy may consume without making a blocking system call. For the purpose of this limit, each time a process makes a blocking system call, the count of its consumed CPU time is reset to zero. The CPU time count is not reset if the process continues trying to use the CPU but is preempted, its time slice expires, or it calls sched_yield(2).
Upon reaching the soft limit, the process is sent a SIGXCPU signal. If the process catches or ignores this signal and continues consuming CPU time, then SIGXCPU will be generated once each second until the hard limit is reached, at which point the process is sent a SIGKILL signal.</p>

<p>The intended use of this limit is to stop a runaway real-time process from locking up the system.</p>

<p>RLIMIT_SIGPENDING (Since Linux 2.6.8)
Specifies the limit on the number of signals that may be queued for the real user ID of the calling process. Both standard and real-time signals are counted for the purpose of checking this limit. However, the limit is only enforced for sigqueue(3); it is always possible to use kill(2) to queue one instance of any of the signals that are not already queued to the process.
RLIMIT_STACK
The maximum size of the process stack, in bytes. Upon reaching this limit, a SIGSEGV signal is generated. To handle this signal, a process must employ an alternate signal stack (sigaltstack(2)).
Since Linux 2.6.23, this limit also determines the amount of space used for the process&rsquo;s command-line arguments and environment variables; for details, see execve(2).</p>

<p>prlimit()</p>

<p>The Linux-specific prlimit() system call combines and extends the functionality of setrlimit() and getrlimit(). It can be used to both set and get the resource limits of an arbitrary process.
The resource argument has the same meaning as for setrlimit() and getrlimit().</p>

<p>If the new_limit argument is a not NULL, then the rlimit structure to which it points is used to set new values for the soft and hard limits for resource. If the old_limit argument is a not NULL, then a successful call to prlimit() places the previous soft and hard limits for resource in the rlimit structure pointed to by old_limit.</p>

<p>The pid argument specifies the ID of the process on which the call is to operate. If pid is 0, then the call applies to the calling process. To set or get the resources of a process other than itself, the caller must have the CAP_SYS_RESOURCE capability, or the real, effective, and saved set user IDs of the target process must match the real user ID of the caller and the real, effective, and saved set group IDs of the target process must match the real group ID of the caller.</p>

<p>Return Value
On success, these system calls return 0. On error, -1 is returned, and errno is set appropriately.</p>

<p>Errors
EFAULT
A pointer argument points to a location outside the accessible address space.</p>

<p>EINVAL</p>

<p>The value specified in resource is not valid; or, for setrlimit() or prlimit(): rlim-&gt;rlim_cur was greater than rlim-&gt;rlim_max.</p>

<p>EPERM</p>

<p>An unprivileged process tried to raise the hard limit; the CAP_SYS_RESOURCE capability is required to do this. Or, the caller tried to increase the hard RLIMIT_NOFILE limit above the current kernel maximum (NR_OPEN). Or, the calling process did not have permission to set limits for the process specified by pid.</p>

<p>ESRCH</p>

<p>Could not find a process with the ID specified in pid.</p>

<p>Versions
The prlimit() system call is available since Linux 2.6.36. Library support is available since glibc 2.13.</p>

<p>Conforming To
getrlimit(), setrlimit(): SVr4, 4.3BSD, POSIX.1-2001.
prlimit(): Linux-specific.</p>

<p>RLIMIT_MEMLOCK and RLIMIT_NPROC derive from BSD and are not specified in POSIX.1-2001; they are present on the BSDs and Linux, but on few other implementations. RLIMIT_RSS derives from BSD and is not specified in POSIX.1-2001; it is nevertheless present on most implementations. RLIMIT_MSGQUEUE, RLIMIT_NICE, RLIMIT_RTPRIO, RLIMIT_RTTIME, and RLIMIT_SIGPENDING are Linux-specific.</p>

<p>Notes
A child process created via fork(2) inherits its parent&rsquo;s resource limits. Resource limits are preserved across execve(2).</p>

<p>One can set the resource limits of the shell using the built-in ulimit command (limit in csh(1)). The shell&rsquo;s resource limits are inherited by the processes that it creates to execute commands.</p>

<p>Since Linux 2.6.24, the resource limits of any process can be inspected via /proc/[pid]/limits; see proc(5).</p>

<p>Ancient systems provided a vlimit() function with a similar purpose to setrlimit(). For backward compatibility, glibc also provides vlimit(). All new applications should be written using setrlimit().</p>

<p>Bugs
In older Linux kernels, the SIGXCPU and SIGKILL signals delivered when a process encountered the soft and hard RLIMIT_CPU limits were delivered one (CPU) second later than they should have been. This was fixed in kernel 2.6.8.</p>

<p>In 2.6.x kernels before 2.6.17, a RLIMIT_CPU limit of 0 is wrongly treated as &ldquo;no limit&rdquo; (like RLIM_INFINITY). Since Linux 2.6.17, setting a limit of 0 does have an effect, but is actually treated as a limit of 1 second.</p>

<p>A kernel bug means that RLIMIT_RTPRIO does not work in kernel 2.6.12; the problem is fixed in kernel 2.6.13.</p>

<p>In kernel 2.6.12, there was an off-by-one mismatch between the priority ranges returned by getpriority(2) and RLIMIT_NICE. This had the effect that the actual ceiling for the nice value was calculated as 19 - rlim_cur. This was fixed in kernel 2.6.13.</p>

<p>Since Linux 2.6.12, if a process reaches its soft RLIMIT_CPU limit and has a handler installed for SIGXCPU, then, in addition to invoking the signal handler, the kernel increases the soft limit by one second. This behavior repeats if the process continues to consume CPU time, until the hard limit is reached, at which point the process is killed. Other implementations do not change the RLIMIT_CPU soft limit in this manner, and the Linux behavior is probably not standards conformant; portable applications should avoid relying on this Linux-specific behavior. The Linux-specific RLIMIT_RTTIME limit exhibits the same behavior when the soft limit is encountered.</p>

<p>Kernels before 2.4.22 did not diagnose the error EINVAL for setrlimit() when rlim-&gt;rlim_cur was greater than rlim-&gt;rlim_max.</p>

<p>Example
The program below demonstrates the use of prlimit().</p>

<p>#define _GNU_SOURCE
#define _FILE_OFFSET_BITS 64
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/resource.h>
#define errExit(msg)
do { perror(msg); exit(EXIT_FAILURE); </p>

<p>} while (0)
int
main(int argc, char *argv[])
{
struct rlimit old, new;
struct rlimit *newp;
pid_t pid;</p>

<p>if (!(argc == 2 || argc == 4)) {
fprintf(stderr, &ldquo;Usage: %s <pid> [<new-soft-limit> &rdquo;
&ldquo;<new-hard-limit>]\n&rdquo;, argv[0]);
exit(EXIT_FAILURE);
}</p>

<p>pid = atoi(argv[1]); /* PID of target process */</p>

<p>newp = NULL;
if (argc == 4) {
new.rlim_cur = atoi(argv[2]);
new.rlim_max = atoi(argv[3]);
newp = &amp;new;
}</p>

<p>/* Set CPU time limit of target process; retrieve and display
previous limit */</p>

<p>if (prlimit(pid, RLIMIT_CPU, newp, &amp;old) == -1)
errExit(&ldquo;prlimit-1&rdquo;);
printf(&ldquo;Previous limits: soft=%lld; hard=%lld\n&rdquo;,
(long long) old.rlim_cur, (long long) old.rlim_max);</p>

<p>/* Retrieve and display new CPU time limit */</p>

<p>if (prlimit(pid, RLIMIT_CPU, NULL, &amp;old) == -1)
errExit(&ldquo;prlimit-2&rdquo;);
printf(&ldquo;New limits: soft=%lld; hard=%lld\n&rdquo;,
(long long) old.rlim_cur, (long long) old.rlim_max);</p>

<p>exit(EXIT_FAILURE);
}
&ldquo;`</p>

    </div>

  </div>
</body>

<footer>
    <div class="container">
        <div class="row footer-links">
            <div class="col-lg-2 col-sm-2">
                <h3>友情链接</h3>
                <ul>
                    <li><a href="">友链位招租</a></li>
                    <li><a href="">友链位招租</a></li>
                </ul>
            </div>
            <div class="col-lg-2 col-sm-2">
                <h3>没想好</h3>
                <ul>
                    <li><a href="">我爸没想好</a></li>
                    <li><a href="">我哥说我爸没想好</a></li>
                </ul>
            </div>
            <div class="col-lg-2 col-sm-2">
                <h3>Hooray</h3>
                <ul>
                    <li><a href="">Hooray</a></li>
                    <li><a href="">What are we Hooray For?</a></li>
                </ul>
            </div>
            <div class="col-lg-2 col-sm-2">
                <h3>前面的footer太浪了</h3>
                <ul>
                    <li><a href="">就是就是</a></li>
                    <li><a href="">偷偷的表示羡慕</a></li>
                </ul>
            </div>
            <div class="col-lg-4 col-sm-4">
                <h3>网站信息</h3>
                <a class="" href="" target="_blank"></a>
                <a class="" href="" target="_blank"></a>
                <a class="" href="" target="_blank"></a>
                <a class="" href="" target="_blank"></a>
                <div class="fine-print">
                    <p>网战由以下技术支撑</p>
                    <ul>
                        <li>Markdown Processor: <a href="https://github.com/russross/blackfriday/tree/v2">Blackfriday V2</a></li>
                        <li>Renderer Engine: <a href="https://github.com/Depado/bfchroma/">bfchroma</a></li>
                        <li>Syntax Highlighter: <a href="https://github.com/alecthomas/chroma">Chroma</a></li>
                        <li>Coding Language: <a href="https://go.dev/">Golang</a></li>
                        <li>Others: Markdown, HTML, CSS</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</footer>

</html>