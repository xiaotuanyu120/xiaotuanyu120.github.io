<!DOCTYPE html>
<html lang="zh-cmn">

<head>
    <title>XTY Blog | Linux Ops Docs | SRE | DEVOPS</title>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
    <link rel="stylesheet" href="/static/css/chroma.css">
    <link rel="stylesheet" href="/static/css/main.css">
</head>

<div class="blog-title">
	<div class="container">
		<div class="row">
			<div class="col-lg-12">
				<div>
					<a class="main-title" href="/">XTY的小站</a>
                </div>
                <div>
                    <a class="small-title" href="/">记录技术笔记和技术博客</a>
                </div>
			</div>
		</div>
	</div>
</div>

<body>
  <div class="container">

    <div class="col-lg-4 col-lg-offset-1 col-md-4 col-md-offset-1 col-sm-4 col-sm-offset-1">
	  <div id="sidebar">

		<h3>最新文章</h3>
          <ul>

            <li>
              <a href="/leetcode/binary_tree/easy_108_convert_sorted_array_to_binary_search_tree.html">108. Convert Sorted Array To Binary Search Tree</a>
            </li>
            <li>
              <a href="/leetcode/binary_tree/easy_543_diameter_of_binary_tree.html">543. Diameter Of Binary Tree</a>
            </li>
            <li>
              <a href="/leetcode/binary_tree/easy_101_symmetric_binary_tree.html">101. Symmetric Binary Tree</a>
            </li>
            <li>
              <a href="/leetcode/binary_tree/easy_226_revert_binary_tree.html">226. Revert Binary Tree</a>
            </li>
            <li>
              <a href="/leetcode/binary_tree/easy_104_maximum_depth_of_binary_tree.html">104. Maximum Depth Of Binary Tree</a>
            </li>
          </ul>

		<h3>文章分类</h3>
		  <ul>

            <li>
              <a href="/android/index.html">android</a>
            </li>
            <li>
              <a href="/bigdata/index.html">bigdata</a>
            </li>
            <li>
              <a href="/blockchain/index.html">blockchain</a>
            </li>
            <li>
              <a href="/blog/index.html">blog</a>
            </li>
            <li>
              <a href="/cloud/index.html">cloud</a>
            </li>
            <li>
              <a href="/leetcode/index.html">leetcode</a>
            </li>
            <li>
              <a href="/cryptography/index.html">cryptography</a>
            </li>
            <li>
              <a href="/database/index.html">database</a>
            </li>
            <li>
              <a href="/devops/index.html">devops</a>
            </li>
            <li>
              <a href="/go/index.html">go</a>
            </li>
            <li>
              <a href="/ios/index.html">ios</a>
            </li>
            <li>
              <a href="/java/index.html">java</a>
            </li>
            <li>
              <a href="/linux/index.html">linux</a>
            </li>
            <li>
              <a href="/python/index.html">python</a>
            </li>
            <li>
              <a href="/service/index.html">service</a>
            </li>
            <li>
              <a href="/virtualization/index.html">virtualization</a>
            </li>
            <li>
              <a href="/web/index.html">web</a>
            </li>
          </ul>

      </div>
    </div>

    <div class="col-lg-7 col-md-7 col-sm-7">

        <div class="article-summary">
        <div class="article-title">
          <a href="leetcode/binary_tree/easy_108_convert_sorted_array_to_binary_search_tree.html">108. Convert Sorted Array To Binary Search Tree</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>14 Jul 2024</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>108. Convert Sorted Array To Binary Search Tree (Easy) 降有序数组转换为二叉搜索树</h2>

<h3>题干</h3>

<p>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert it to a <strong>height-balanced</strong> <em>binary search tree</em>.</p>

<blockquote>
<p>A <strong>height-balanced</strong> binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p>
</blockquote>

<p><strong>Example 1:</strong></p>

<p><img src="/static/images/docs/leetcode/binary_tree/108_example_1.jpg" alt="img" /></p>
<pre class="chroma">Input: nums = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: [0,-10,5,null,-3,null,9] is also accepted:
</pre>
<p><strong>Example 2:</strong></p>

<p><img src="/static/images/docs/leetcode/binary_tree/108_example_2.jpg" alt="img" /></p>
<pre class="chroma">Input: nums = [1,3]
Output: [3,1]
Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.
</pre>
<p><strong>Constraints:</strong></p>

<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> is sorted in a <strong>strictly increasing</strong> order.</li>
</ul>

<h3>解法</h3>

<h4>朴素解法</h4>

<p>有序数组，组成高度平衡的二叉搜索树。重点就在于找到中间值，然后左右区间分别构造二叉树的左右子树。</p>

<p>递归解法</p>

<ul>
<li>输入参数：输入一个数组</li>
<li>输出参数：输出一个二叉树节点</li>
<li>终止条件：

<ul>
<li>当数组长度等于1时，返回二叉树节点，值等于元素，左右子节点等于None</li>
</ul></li>
<li>单层核心逻辑：

<ul>
<li>当前数组长度整除2，结果就是中间值的index</li>
<li>将当前中间值作为value</li>
<li>分别把左区间[0:index]和右区间[index+1:]的返回值，当作当前节点的左右子节点</li>
</ul></li>
</ul>
<pre class="chroma"><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">sortedArrayToBST</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span><span class="p">:</span>
        <span class="n">len_nums</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">len_nums</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="n">len_nums</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="p">)</span>
        <span class="n">root_i</span> <span class="o">=</span> <span class="n">len_nums</span> <span class="o">/</span><span class="o">/</span> <span class="mi">2</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">root_i</span><span class="p">]</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sortedArrayToBST</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="p">:</span><span class="n">root_i</span><span class="p">]</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sortedArrayToBST</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">root_i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="p">]</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span>
</pre>
        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="leetcode/binary_tree/easy_543_diameter_of_binary_tree.html">543. Diameter Of Binary Tree</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>14 Jul 2024</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>543. Diameter Of Binary Tree [Easy] 二叉树的直径</h2>

<h3>题干</h3>

<p>Given the <code>root</code> of a binary tree, return *the length of the <strong>diameter</strong> of the tree*.</p>

<p>The <strong>diameter</strong> of a binary tree is the <strong>length</strong> of the longest path between any two nodes in a tree. This path may or may not pass through the <code>root</code>.</p>

<p>The <strong>length</strong> of a path between two nodes is represented by the number of edges between them.</p>

<p><strong>Example 1:</strong></p>

<p><img src="/static/images/docs/leetcode/binary_tree/543_example_1.jpg" alt="img" /></p>
<pre class="chroma">Input: root = [1,2,3,4,5]
Output: 3
Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].
</pre>
<p><strong>Example 2:</strong></p>
<pre class="chroma">Input: root = [1,2]
Output: 1
</pre>
<p><strong>Constraints:</strong></p>

<ul>
<li>The number of nodes in the tree is in the range <code>[1, 104]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<h3>解法</h3>

<h4>递归解法</h4>

<p>核心思路：</p>

<ul>
<li>将问题转换为求每个节点的左右子树高度之和，后序遍历</li>
</ul>

<p>递归实现（返回节点高度，同时计算递归过程中各个节点的最长直径；这两者都是后序遍历，所以可以循只遍历一次）：</p>

<ul>
<li>输入参数：Optional[TreeNode]</li>
<li>输出参数：int（高度）</li>
<li>终止条件：None节点的高度为0，返回它</li>
<li>单层核心逻辑：

<ul>
<li>返回节点高度</li>
<li>计算左节点的高度，计算右节点的高度</li>
<li>取最大值+1，并返回</li>
<li>更新全局最长直径</li>
</ul></li>
</ul>
<pre class="chroma"><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">diameterOfBinaryTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_diameter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getHeight</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_diameter</span>
    
    <span class="k">def</span> <span class="nf">getHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 终止条件</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="c1"># 后序遍历</span>
        <span class="n">left_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeight</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeight</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_diameter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">left_h</span> <span class="o">+</span> <span class="n">right_h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_diameter</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">left_h</span><span class="p">,</span> <span class="n">right_h</span><span class="p">)</span>
</pre>
        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="leetcode/binary_tree/easy_101_symmetric_binary_tree.html">101. Symmetric Binary Tree</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>14 Jul 2024</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>101. Symmetric Binary Tree (Easy) 对称二叉树</h2>

<h3>题干</h3>

<p>Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p>

<p><strong>Example 1:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="img" /></p>
<pre class="chroma">Input: root = [1,2,2,3,4,4,3]
Output: true
</pre>
<p><strong>Example 2:</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt="img" /></p>
<pre class="chroma">Input: root = [1,2,2,null,3,null,3]
Output: false
</pre>
<p><strong>Constraints:</strong></p>

<ul>
<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p><strong>Follow up:</strong> Could you solve it both recursively and iteratively?</p>

<h3>解法</h3>

<h4>递归解法</h4>

<p>核心思路：将根节点的左右子树递归对称对比，单个节点的对比包含以下规则：</p>

<ul>
<li>两个节点都为None的时候，是对称的</li>
<li>两个节点只有一个是None的时候，不对称</li>
<li>两个节点都不是None，value不相同的时候，不对称</li>
<li>两个节点都不是None，节点value相同，并且左右子树递归对称的时候，对称</li>
</ul>

<p>递归实现：</p>

<ul>
<li>输入参数：两个Optional[TreeNode]</li>
<li>输出参数：bool</li>
<li>终止条件：

<ul>
<li>两个节点都是None，返回True</li>
<li>只有一个是None，返回False</li>
<li>两个节点不为None，value不同，返回False</li>
</ul></li>
<li>单层核心逻辑：

<ul>
<li>节点1的左子树和节点2的右子树对比</li>
<li>节点1的右子树和节点2的左子树对比</li>
<li>节点1和节点2的对比</li>
</ul></li>
</ul>

<blockquote>
<p>两个节点的<code>val</code>对比属于终止条件，并不是中节点的比较，因为节点的比较，除了val之外，还有left和right的对比。</p>

<p>单层核心逻辑，<code>左右中</code>是后序遍历。</p>
</blockquote>
<pre class="chroma"><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSymmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isSame</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">isSame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_01</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span><span class="p">,</span> <span class="n">node_02</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># 终止条件</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node_01</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node_02</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node_01</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">node_02</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">node_01</span><span class="o">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">node_02</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="c1"># 后序处理，左右中（中隐藏在return的逻辑里面了）</span>
        <span class="c1"># 注意，中是指中节点，当前节点的val对比并不是中节点完整的逻辑对比，所以不算中</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isSame</span><span class="p">(</span><span class="n">node_01</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node_02</span><span class="o">.</span><span class="n">right</span><span class="p">)</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isSame</span><span class="p">(</span><span class="n">node_01</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node_02</span><span class="o">.</span><span class="n">left</span><span class="p">)</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</pre>
        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="leetcode/binary_tree/easy_226_revert_binary_tree.html">226. Revert Binary Tree</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>14 Jul 2024</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>226. Revert Binary Tree (Easy) 反转二叉树</h2>

<h3>题干</h3>

<p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p>

<p><strong>Example 1:</strong></p>

<p><img src="/static/images/docs/leetcode/binary_tree/226_example_1.jpg" alt="img" /></p>
<pre class="chroma">Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]
</pre>
<p><strong>Example 2:</strong></p>

<p><img src="/static/images/docs/leetcode/binary_tree/226_example_2.jpg" alt="img" /></p>
<pre class="chroma">Input: root = [2,1,3]
Output: [2,3,1]
</pre>
<p><strong>Example 3:</strong></p>
<pre class="chroma">Input: root = []
Output: []
</pre>
<p><strong>Constraints:</strong></p>

<ul>
<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<h3>解法</h3>

<h4>递归解法</h4>

<p>核心思想：使用前序或后序遍历来处理。</p>

<blockquote>
<p>中序遍历不行的原因是，在左和右子树分别处理完之前，就把中的逻辑（交换左右子树）处理了，相当于左右子树发生了改变，逻辑会比较绕。</p>
</blockquote>

<p>递归实现：</p>

<ul>
<li>输入参数：Optional[TreeNode]</li>
<li>输出参数：空</li>
<li>终止条件：如果传入参数为None，返回</li>
<li>单层核心逻辑：按照前序或者后序遍历处理</li>
</ul>
<pre class="chroma"><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">invertTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invertNode</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span>
        
    <span class="k">def</span> <span class="nf">invertNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span><span class="p">)</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># 前序遍历</span>
        <span class="c1"># 处理`中`，交换左右子树</span>
        <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span>
        <span class="c1"># 递归处理左子树</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invertNode</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="c1"># 递归处理右子树</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invertNode</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
</pre>
        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="leetcode/binary_tree/easy_104_maximum_depth_of_binary_tree.html">104. Maximum Depth Of Binary Tree</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>14 Jul 2024</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>104. Maximum Depth Of Binary Tree (Easy) 栈的最大深度</h2>

<h3>题干</h3>

<p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p>

<p>A binary tree&rsquo;s <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>

<p><strong>Example 1:</strong></p>

<p><img src="/static/images/docs/leetcode/binary_tree/104_example_1.jpg" alt="img" /></p>
<pre class="chroma">Input: root = [3,9,20,null,null,15,7]
Output: 3
</pre>
<p><strong>Example 2:</strong></p>
<pre class="chroma">Input: root = [1,null,2]
Output: 2
</pre>
<p><strong>Constraints:</strong></p>

<ul>
<li>The number of nodes in the tree is in the range <code>[0, 104]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<h3>解法</h3>

<h4>递归解法</h4>

<p>核心思想：求最大深度，其实就是求root的高度。求高度使用的是后序遍历，左右中</p>

<blockquote>
<p><code>左右中</code>，最后处理<code>中</code>，才能递归把<code>左</code>和<code>右</code>的结果，拿来给<code>中</code>用。</p>

<p>为什么不使用前序遍历，中左右，来直接求深度呢？因为无法让下层节点利用上层节点来递归</p>
</blockquote>

<p>递归实现：</p>

<ul>
<li>输入参数：Optional[node]</li>
<li>输出参数：int(高度)</li>
<li>结束条件：如果传入的node为空，则返回0（最下层元素的高度是1，那么None的就是0）</li>
<li>单层核心逻辑：递归求左右子节点的高度，然后将较大的值加上1，就是当前节点的高度</li>
</ul>
<pre class="chroma"><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeight</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">getHeight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 终止条件</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># 单层核心逻辑</span>
        <span class="c1"># 以下四条语句，可以合并为最后一条语句</span>
        <span class="c1"># left_height = self.getHeight(node.left)</span>
        <span class="c1"># right_height = self.getHeight(node.right)</span>
        <span class="c1"># cur_height = max(left_height, right_height) + 1</span>
        <span class="c1"># return cur_height</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getHeight</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHeight</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span><span class="p">)</span>

</pre>
        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="leetcode/binary_tree/easy_94_binary_tree_inorder_traversal.html">94. Binary Tree Inorder Traversal</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>06 Jul 2024</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>94. Binary Tree Inorder Traversal (Easy) 二叉树的中序遍历</h2>

<h3>题干</h3>

<p>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes&rsquo; values</em>.</p>

<p><strong>Example 1:</strong></p>

<p><img src="/static/images/docs/leetcode/binary_tree/94_example_1.jpg" alt="img" /></p>
<pre class="chroma">Input: root = [1,null,2,3]
Output: [1,3,2]
</pre>
<p><strong>Example 2:</strong></p>
<pre class="chroma">Input: root = []
Output: []
</pre>
<p><strong>Example 3:</strong></p>
<pre class="chroma">Input: root = [1]
Output: [1]
</pre>
<p><strong>Constraints:</strong></p>

<ul>
<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>

<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>

<h3>解法</h3>

<h4>递归解法</h4>

<p>中序遍历，就是左中右这种顺序</p>

<ul>
<li>输入参数：node节点，保存结果的列表</li>
<li>输出参数：空</li>
<li>结束条件：当node是None的时候直接返回</li>
<li>单层关键逻辑：当node不是None的时候，先处理左节点（需递归），将结果加入到结果，然后是中节点（当前节点，无需递归），然后时右节点（需递归）。</li>
</ul>
<pre class="chroma"><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traversal</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
    
    <span class="k">def</span> <span class="nf">traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span><span class="p">,</span> <span class="n">res</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="p">)</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">traversal</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traversal</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
</pre>
<h4>栈解法</h4>

<p>中序遍历，就是左中右顺序。</p>

<ul>
<li>栈中保存需要后序处理的节点（当前节点的左子树上所有的左节点），直到当前节点为None</li>
<li>从栈中弹出元素，记录当前元素的值，然后使用当前节点的right节点当作当前节点，进入下次循环</li>
</ul>
<pre class="chroma"><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, val=0, left=None, right=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.left = left</span>
<span class="c1">#         self.right = right</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="p">:</span>
        <span class="n">answer</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="p">]</span>
        <span class="n">st_node</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="p">]</span>
        <span class="n">cur_node</span> <span class="o">=</span> <span class="n">root</span>

        <span class="c1"># 中序遍历：左中右</span>
        <span class="c1"># 左子树依序入栈，到底后逐个弹出，处理中和右</span>
        <span class="k">while</span> <span class="n">cur_node</span> <span class="ow">or</span> <span class="n">st_node</span><span class="p">:</span>
            <span class="c1"># 先处理当前节点的左子树</span>
            <span class="k">while</span> <span class="n">cur_node</span><span class="p">:</span>
                <span class="n">st_node</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_node</span><span class="p">)</span>
                <span class="n">cur_node</span> <span class="o">=</span> <span class="n">cur_node</span><span class="o">.</span><span class="n">left</span>

            <span class="c1"># 将栈顶元素弹出栈（左节点首先会在栈顶）</span>
            <span class="n">cur_node</span> <span class="o">=</span> <span class="n">st_node</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="p">)</span>
            <span class="n">answer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

            <span class="c1"># 若无right，cur_node为None，会在下个循环中重新pop一个</span>
            <span class="n">cur_node</span> <span class="o">=</span> <span class="n">cur_node</span><span class="o">.</span><span class="n">right</span>
        
        <span class="k">return</span> <span class="n">answer</span>
</pre>
        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="leetcode/binary_tree/binary_tree.html">Binary Tree</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>06 Jul 2024</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h3>二叉树的定义</h3>

<p>在<a href="https://zh.wikipedia.org/wiki/電腦科學">电脑科学</a>中，<strong>二叉树</strong>（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的<a href="https://zh.wikipedia.org/wiki/树结构">树结构</a>[<a href="https://zh.wikipedia.org/zh-sg/二叉树#cite_note-1">1]</a>。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。</p>

<p>二叉树的第i层至多拥有2i−1个节点；深度为k的二叉树至多总共有2k+1−1个节点（定义根节点所在深度 k0=0!），而总计拥有节点数符合的，称为“满二叉树”；深度为k有n个节点的二叉树，当且仅当其中的每一节点，都可以和深度k的满二叉树，序号1到n的节点一对一对应时，称为<a href="https://zh.wikipedia.org/wiki/完全二叉树">完全二叉树</a>。对任何一棵非空的二叉树T，如果其叶片（终端节点）数为n0，分支度为2的节点数为n2，则n0=n2+1。</p>

<h3>二叉树的发展历史</h3>

<ol>
<li><strong>早期背景和数学基础</strong>：

<ul>
<li>在计算机科学发展之前，树结构的概念已经在数学中存在。数学家和图论专家研究了树的性质和特点。</li>
<li>计算机科学的发展从20世纪中期开始，数据结构和算法的研究逐渐兴起。</li>
</ul></li>
<li><strong>20世纪50年代</strong>：

<ul>
<li>二叉树在计算机科学中开始被正式研究和应用。1950年代是二叉树概念的形成时期。</li>
<li>当时的计算机科学家开始研究如何有效地存储和检索数据，二叉树被发现是一种有效的数据结构，尤其是在实现搜索和排序操作时。</li>
</ul></li>
<li><strong>二叉搜索树 (BST)</strong>：

<ul>
<li>二叉搜索树是一种特殊的二叉树，其中左子节点的值总是小于父节点的值，右子节点的值总是大于父节点的值。</li>
<li>1959年，二叉搜索树的概念被正式提出，成为一种广泛使用的数据结构，用于高效的数据查找和排序。</li>
</ul></li>
<li><strong>自平衡二叉树</strong>：

<ul>
<li>1962年，G.M. Adelson-Velsky 和 E.M. Landis 提出了 AVL树，这是第一种自平衡二叉搜索树。AVL树通过在插入和删除节点时进行旋转操作，保持树的平衡，从而保证了操作的时间复杂度为O(log n)。</li>
<li>1972年，Rudolf Bayer 发明了红黑树，这是一种自平衡二叉搜索树，进一步提高了效率和稳定性。</li>
</ul></li>
<li><strong>其他变体和应用</strong>：

<ul>
<li>随着计算机科学的发展，二叉树的其他变体（如堆、B树、Trie树等）被广泛研究和应用在不同的领域，如数据库、编译器、网络路由等。</li>
<li>二叉树在算法设计、数据压缩（如哈夫曼编码）、表达式解析和计算等方面有着广泛的应用。</li>
</ul></li>
</ol>

<h3>二叉树的种类</h3>

<p>根据结构和性质的不同，二叉树可以分为许多种类。以下是一些常见的二叉树种类及其特点：</p>

<ol>
<li><strong>完全二叉树（Complete Binary Tree）</strong></li>
</ol>

<ul>
<li><strong>定义</strong>：除了最后一层外，其他每一层的节点数都达到最大，且最后一层的节点都集中在最左边。</li>
<li><strong>特点</strong>：叶子节点只能出现在最后两层，并且最后一层的叶子节点都靠左排列。</li>
</ul>

<ol>
<li><strong>满二叉树（Full Binary Tree）</strong></li>
</ol>

<ul>
<li><strong>定义</strong>：每个节点要么有两个子节点，要么没有子节点。</li>
<li><strong>特点</strong>：叶子节点都在同一层，且每个非叶子节点都有两个子节点。</li>
</ul>

<ol>
<li><strong>平衡二叉树（Balanced Binary Tree）</strong></li>
</ol>

<ul>
<li><strong>定义</strong>：任意节点的左右子树的高度差不超过1。</li>
<li><strong>特点</strong>：为了保证查找、插入和删除操作的时间复杂度保持在 O(log n) 级别。</li>
</ul>

<ol>
<li><strong>二叉搜索树（Binary Search Tree，BST）</strong></li>
</ol>

<ul>
<li><strong>定义</strong>：对任意节点，左子树上所有节点的值都小于该节点的值，右子树上所有节点的值都大于该节点的值。</li>
<li><strong>特点</strong>：支持高效的查找、插入和删除操作。</li>
</ul>

<p><strong>总结</strong>
二叉树还有很多其他种类，每种都有其特定的用途和性质。根据具体应用场景选择合适的二叉树可以提高算法的效率和性能。</p>

<h3>二叉树的重要性</h3>

<ul>
<li><strong>高效查找</strong>：二叉搜索树允许在平均O(log n)的时间内进行查找操作。</li>
<li><strong>排序功能</strong>：通过中序遍历二叉搜索树，可以获得有序的数据序列。</li>
<li><strong>灵活性和扩展性</strong>：二叉树的变体（如AVL树、红黑树、B树等）在保持效率的同时，适应不同的应用场景和需求。</li>
<li><strong>基础性</strong>：二叉树是很多复杂数据结构和算法的基础，如图的遍历、表达式解析、哈夫曼编码等。</li>
</ul>

<p>综上所述，二叉树作为一种基础的数据结构，在计算机科学的发展中起到了重要的作用。从最初的数学概念到如今各种复杂的变体和应用，二叉树一直是计算机科学研究和应用的核心部分。</p>

<h3>二叉树在内存中的储存</h3>

<p>二叉树在内存中，使用链式存储。</p>

<blockquote>
<p>也有线性存储，即使用数组来存储。</p>
</blockquote>

<p>假设我们在一个32位系统上，<code>int</code> 和指针都占用4个字节（32位）。我们将<code>val</code>设置为42，并假设<code>left</code>和<code>right</code>指针为空（即<code>NULL</code>）。</p>

<p>在二进制位模式下：</p>

<ul>
<li><code>42</code> 的二进制表示是 <code>00000000 00000000 00000000 00101010</code>。</li>
<li><code>NULL</code> 的二进制表示是 <code>00000000 00000000 00000000 00000000</code>。</li>
</ul>

<p>因此，内存布局将是：</p>
<pre class="chroma">地址:    0x1000   0x1004   0x1008   0x100C
        +--------+--------+--------+--------+
值:     |   42   |  NULL  |  NULL  |
        +--------+--------+--------+--------+
字段:   |  val   |  left  |  right |
        +--------+--------+--------+--------+
</pre>
<blockquote>
<p>64位系统中，val值不够长度会进行补齐，保持长度和后面的指针一致。</p>
</blockquote>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="leetcode/linked_list/easy_21_merge_two_sorted_list.html">21. Merge Two Sorted List</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>05 Jul 2024</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>21. Merge Two Sorted List (Easy) 合并有序链表</h2>

<h3>题干</h3>

<p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p>

<p>Merge the two lists into one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p>

<p>Return <em>the head of the merged linked list</em>.</p>

<p><strong>Example 1:</strong></p>

<p><img src="/static/images/docs/leetcode/linked_list/21_example_1.jpg" alt="img" /></p>
<pre class="chroma">Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
</pre>
<p><strong>Example 2:</strong></p>
<pre class="chroma">Input: list1 = [], list2 = []
Output: []
</pre>
<p><strong>Example 3:</strong></p>
<pre class="chroma">Input: list1 = [], list2 = [0]
Output: [0]
</pre>
<p><strong>Constraints:</strong></p>

<ul>
<li>The number of nodes in both lists is in the range <code>[0, 50]</code>.</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li>Both <code>list1</code> and <code>list2</code> are sorted in <strong>non-decreasing</strong> order.</li>
</ul>

<h3>解法</h3>

<h4>朴素解法</h4>
<pre class="chroma"><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, val=0, next=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.next = next</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeTwoLists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]</span><span class="p">,</span> <span class="n">list2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]</span><span class="p">:</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="p">)</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="n">pre</span>

        <span class="k">while</span> <span class="n">list1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">list2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">list1</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">list2</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">list2</span>
                <span class="n">list2</span> <span class="o">=</span> <span class="n">list2</span><span class="o">.</span><span class="n">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">list1</span>
                <span class="n">list1</span> <span class="o">=</span> <span class="n">list1</span><span class="o">.</span><span class="n">next</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="n">next</span>
        <span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">list1</span> <span class="k">if</span> <span class="n">list1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">list2</span>
        <span class="k">return</span> <span class="n">pre</span><span class="o">.</span><span class="n">next</span>
</pre>
<blockquote>
<ul>
<li>使用一个pre节点，避免了处理第一个节点的特殊情况</li>
<li>while循环只处理两个链表都没到尾部的情况，其他一个到尾部时单独处理，这样避免了重复判断None的语句。</li>
</ul>
</blockquote>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="leetcode/linked_list/easy_206_reverse_linked_list.html">206. Reverse Linked List</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>04 Jul 2024</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>206. Reverse Linked List (Easy) 反转链表</h2>

<h3>题干</h3>

<p>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p>

<p><strong>Example 1:</strong></p>

<p><img src="/static/images/docs/leetcode/linked_list/206_examle_1.jpg" alt="img" /></p>
<pre class="chroma">Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
</pre>
<p><strong>Example 2:</strong></p>

<p><img src="/static/images/docs/leetcode/linked_list/206_examle_2.jpg" alt="img" /></p>
<pre class="chroma">Input: head = [1,2]
Output: [2,1]
</pre>
<p><strong>Example 3:</strong></p>
<pre class="chroma">Input: head = []
Output: []
</pre>
<p><strong>Constraints:</strong></p>

<ul>
<li>The number of nodes in the list is the range <code>[0, 5000]</code>.</li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>

<p><strong>Follow up:</strong> A linked list can be reversed either iteratively or recursively. Could you implement both?</p>

<h3>解法</h3>

<h4>朴素解法（双指针）</h4>

<p>第一个元素指向None，然后后续元素逐个指向前一个元素，完毕</p>
<pre class="chroma"><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, val=0, next=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.next = next</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]</span><span class="p">:</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">next</span>
            <span class="n">cur</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pre</span>
            <span class="n">pre</span><span class="p">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">,</span> <span class="n">next_node</span>
        <span class="k">return</span> <span class="n">pre</span>
</pre>
<ul>
<li>Time Cost: O(n)</li>
<li>Space Cost: O(1)</li>
</ul>

<h4>递归解法</h4>

<p>其实还是双指针，只是换了递归的写法</p>
<pre class="chroma"><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, val=0, next=None):</span>
<span class="c1">#         self.val = val</span>
<span class="c1">#         self.next = next</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]</span><span class="p">,</span> <span class="n">cur</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cur</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pre</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">next</span>
        <span class="n">cur</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pre</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>
</pre>
        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="leetcode/linked_list/easy_141_linked_list_cycle.html">141. Linked List Cycle</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>04 Jul 2024</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>141. Linked List Cycle (Easy) 环形链表</h2>

<h3>题干</h3>

<p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p>

<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail&rsquo;s <code>next</code> pointer is connected to. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.</p>

<p>Return <code>true</code> <em>if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.</p>

<p><strong>Example 1:</strong></p>

<p><img src="/static/images/docs/leetcode/linked_list/141_example_1.png" alt="img" /></p>
<pre class="chroma">Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
</pre>
<p><strong>Example 2:</strong></p>

<p><img src="/static/images/docs/leetcode/linked_list/141_example_2.png" alt="img" /></p>
<pre class="chroma">Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.
</pre>
<p><strong>Example 3:</strong></p>

<p><img src="/static/images/docs/leetcode/linked_list/141_example_3.png" alt="img" /></p>
<pre class="chroma">Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
</pre>
<p><strong>Constraints:</strong></p>

<ul>
<li>The number of the nodes in the list is in the range <code>[0, 104]</code>.</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>
</ul>

<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>

<h3>解法</h3>

<h4>朴素解法</h4>

<p>使用一个备忘录，记录每个节点，若后面有重复，即节点存入前，节点已经存在。那么就有环形存在</p>
<pre class="chroma"><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.next = None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">hasCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">temp</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">head</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">head</span> <span class="ow">in</span> <span class="n">temp</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
        <span class="k">return</span> <span class="bp">False</span>
</pre>
<ul>
<li>Time Cost: O(n^2)</li>
<li>Space Cost: O(n)</li>
</ul>

<h4>优化解法</h4>

<p>基于朴素解法，只是数据结构换成了dict</p>
<pre class="chroma"><span class="c1"># Definition for singly-linked list.</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.next = None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">hasCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">temp</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">ListNode</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="p">}</span>
        <span class="k">while</span> <span class="n">head</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">head</span> <span class="ow">in</span> <span class="n">temp</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
        <span class="k">return</span> <span class="bp">False</span>
</pre>
        </div>

    </div>

  </div>
</body>

<footer>
    <div class="container">
        <div class="row footer-links">
            <div class="col-lg-2 col-sm-2">
                <h3>友情链接</h3>
                <ul>
                    <li><a href="">友链位招租</a></li>
                    <li><a href="">友链位招租</a></li>
                </ul>
            </div>
            <div class="col-lg-2 col-sm-2">
                <h3>没想好</h3>
                <ul>
                    <li><a href="">我爸没想好</a></li>
                    <li><a href="">我哥说我爸没想好</a></li>
                </ul>
            </div>
            <div class="col-lg-2 col-sm-2">
                <h3>Hooray</h3>
                <ul>
                    <li><a href="">Hooray</a></li>
                    <li><a href="">What are we Hooray For?</a></li>
                </ul>
            </div>
            <div class="col-lg-2 col-sm-2">
                <h3>前面的footer太浪了</h3>
                <ul>
                    <li><a href="">就是就是</a></li>
                    <li><a href="">偷偷的表示羡慕</a></li>
                </ul>
            </div>
            <div class="col-lg-4 col-sm-4">
                <h3>网站信息</h3>
                <a class="" href="" target="_blank"></a>
                <a class="" href="" target="_blank"></a>
                <a class="" href="" target="_blank"></a>
                <a class="" href="" target="_blank"></a>
                <div class="fine-print">
                    <p>网战由以下技术支撑</p>
                    <ul>
                        <li>Markdown Processor: <a href="https://github.com/russross/blackfriday/tree/v2">Blackfriday V2</a></li>
                        <li>Renderer Engine: <a href="https://github.com/Depado/bfchroma/">bfchroma</a></li>
                        <li>Syntax Highlighter: <a href="https://github.com/alecthomas/chroma">Chroma</a></li>
                        <li>Coding Language: <a href="https://go.dev/">Golang</a></li>
                        <li>Others: Markdown, HTML, CSS</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</footer>

</html>