<!DOCTYPE html>
<html lang="zh-cmn">

<head>
    <title>XTY Blog | Linux Ops Docs | SRE | DEVOPS</title>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
    <link rel="stylesheet" href="/static/css/chroma.css">
    <link rel="stylesheet" href="/static/css/main.css">
</head>

<div class="blog-title">
	<div class="container">
		<div class="row">
			<div class="col-lg-12">
				<div>
					<a class="main-title" href="/">XTY的小站</a>
                </div>
                <div>
                    <a class="small-title" href="/">记录技术笔记和技术博客</a>
                </div>
			</div>
		</div>
	</div>
</div>

<body>
  <div class="container">

    <div class="col-lg-4 col-lg-offset-1 col-md-4 col-md-offset-1 col-sm-4 col-sm-offset-1">
	  <div id="sidebar">

		<h3>最新文章</h3>
          <ul>

            <li>
              <a href="/service/apache/1.0.1_apache_work_mode.html">apache: 理论 - 工作模式</a>
            </li>
            <li>
              <a href="/linux/advance/memory_03_general_memory_layout.html">内存: 进程内存布局 - 堆栈</a>
            </li>
            <li>
              <a href="/service/nginx/nginx_2.1.9.03_configuration_log.html">nginx: 配置 - 日志</a>
            </li>
            <li>
              <a href="/linux/advance/network_tunnel-ipip.html">网络: 隧道 - IPIP</a>
            </li>
            <li>
              <a href="/linux/advance/network_ip-address.html">网络: IP - IP地址简介</a>
            </li>
          </ul>

		<h3>文章分类</h3>
		  <ul>

            <li>
              <a href="/android/index.html">android</a>
            </li>
            <li>
              <a href="/bigdata/index.html">bigdata</a>
            </li>
            <li>
              <a href="/blockchain/index.html">blockchain</a>
            </li>
            <li>
              <a href="/blog/index.html">blog</a>
            </li>
            <li>
              <a href="/cloud/index.html">cloud</a>
            </li>
            <li>
              <a href="/cryptography/index.html">cryptography</a>
            </li>
            <li>
              <a href="/database/index.html">database</a>
            </li>
            <li>
              <a href="/devops/index.html">devops</a>
            </li>
            <li>
              <a href="/go/index.html">go</a>
            </li>
            <li>
              <a href="/ios/index.html">ios</a>
            </li>
            <li>
              <a href="/java/index.html">java</a>
            </li>
            <li>
              <a href="/linux/index.html">linux</a>
            </li>
            <li>
              <a href="/python/index.html">python</a>
            </li>
            <li>
              <a href="/service/index.html">service</a>
            </li>
            <li>
              <a href="/virtualization/index.html">virtualization</a>
            </li>
            <li>
              <a href="/web/index.html">web</a>
            </li>
          </ul>

      </div>
    </div>

    <div class="col-lg-7 col-md-7 col-sm-7">

        <div class="article-summary">
        <div class="article-title">
          <a href="service/apache/1.0.1_apache_work_mode.html">apache: 理论 - 工作模式</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>10 Aug 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>0. 环境背景</h2>

<p>apache httpd version 2.4.54</p>

<h2>1. apache HTTP 的MPMs</h2>

<p>apache HTTP被设计为一个可以在不同环境下工作在不同平台的强大且灵活的web服务器。不同环境和不同平台通常需要不同的特性，或者同一个特性需要不同的实现方式。apache HTTP通过模块化的设计特点充分的满足了不同的场景的需求。</p>

<p>apache HTTP 2.0将这个模块化的设计延展到了它本身作为一个web服务器最基础的功能上。它创建了一个特殊模块，MPMs(Multi-Processing Moudles)，其负责网络端口监听、接收请求和分发请求给子进程。</p>

<p>通过在基础功能上的模块化，得到了如下好处</p>

<ul>
<li>apache HTTP能更优雅，更高效的支持更多不同的操作系统平台。比如说，apache HTTP windows版本的mpm_winnt能使用原生的网络特性。</li>
<li>apache HTTP能更灵活的被定制。比如说，需要可靠性和兼容性的，可以用prefork；需要更高伸缩性的站点，可以用worker或event。</li>
</ul>

<p>在用户视角，MPMs和其他的普通模块没有什么不同，但是不同的是，MPMs同时只能加载一个。</p>

<p>在类UNIX系统平台上，只有三种MPM可选，prefork、worker和event。</p>

<blockquote>
<ul>
<li>当服务器不支持线程，也支持线程安全时，MPMs默认是prefork</li>
<li>当服务器支持线程，但不支持线程安全时，MPMs默认是woker</li>
<li>当服务器支持线程，也支持线程安全时，MPMs默认是event</li>
</ul>
</blockquote>

<h3>1.1 <code>prefork</code></h3>

<p><code>prefork</code>使用多个子进程，每个子进程只有一个线程。每个进程在某个确定的时间只能维持一个连接，效率高，但内存占用量比较大。</p>

<p>这个非线程型的、预派生的web服务器，它适合于没有线程安全库，需要避免线程兼容性问题的系统。它是要求将每个请求相互独立的情况下最好的MPM，这种模式下，一个请求出现问题不会影响到其他请求。</p>

<h4><strong>配置重点</strong></h4>

<p><code>prefork</code>这种MPM能很好的自我调节，所以需要很少的配置。重点是<code>MaxRequestWorkers</code>要设置的足够大，可以处理足够多的请求，同时需要设置的足够小，至少保证可以给所有的进程分配足够的物理内存。</p>

<h4><strong>工作原理</strong></h4>

<p>一个控制进程作为父进程来启动多个子进程，每个子进程负责监听请求连接并处理请求。</p>

<p>apache HTTP会通过相关配置(<code>StartServers</code>,<code>MinSpareServers</code>,<code>MaxSpareServers</code>,<code>MaxRequestWorkers</code>)动态调整进程数量，以保留足够的空闲进程来随时响应请求。</p>

<p>当需要同时处理超过256个请求时，可以调大<code>MaxRequestWorkers</code>和<code>ServerLimit</code>来增强请求处理能力；当服务器内存紧张时，可以调小<code>MaxRequestWorkers</code>来节省内存。</p>

<p><code>MaxConnectionsPerChild</code>配置了一个子进程能处理的最大请求数，超过这个数目，该子进程就会停止处理新请求，然后被杀掉，重新创建一个新的子进程（为了有效的避免内存泄漏）。</p>

<h3>1.2 <code>worker</code></h3>

<p><code>worker</code>使用多个子进程，每个子进程有多个线程，每个线程在某个确定的时间只能维持一个连接，内存占用量比较小，适合高流量的http服务器。缺点是假如一个线程崩溃，整个进程就会连同其任何线程一起&rdquo;死掉&rdquo;，所以要保证一个进程在运行时必须被系统识别为&rdquo;每个线程都是安全的&rdquo;。</p>

<p>这个支持混合多线程多进程的web服务器，由于使用线程来处理请求，所以可以处理海量请求，而系统资源的开销小于基于进程的MPM。但是它也使用了多进程，每个进程又有多个线程，以获得基于进程的稳定性。</p>

<h4><strong>配置重点</strong></h4>

<p><code>worker</code> MPM，使用<code>ThreadsPerChild</code>来指定每个子进程的线程数量上限，使用<code>MaxRequestWorkers</code>来指定所有进程的线程数量总和上限。</p>

<h4><strong>工作原理</strong></h4>

<p>一个控制进程作为父进程来启动多个子进程，每个子进程创建固定数量的处理请求的线程以及一个监听线程，监听线程会监听请求连接，并将它们转交给处理请求的线程来处理。</p>

<p>apache HTTP 会通过相关配置(<code>MinSpareThreads</code>,<code>MaxSpareThreads</code>)来动态调整线程和进程数量，以保留足够的空闲线程来随时响应请求。</p>

<p>使用<code>worker</code> MPM时，最大处理的连接请求数量由<code>MaxRequestWorkers</code>限定；最大子进程数量由<code>MaxRequestWorkers</code>除以<code>ThreadsPerChild</code>的值来限定。</p>

<p>另外，有两个单独的配置来决定子进程和子进程中线程的绝对上限，这个配置只能完全停止apache HTTP进程，然后再启动才可以更改。其中<code>ServerLimit</code>是子进程的绝对上限值，必须要大于或等于<code>MaxRequestWorkers</code>除以<code>ThreadsPerChild</code>的值。<code>ThreadLimit</code>是子进程中线程的绝对上限值，必须要大于或者等于<code>ThreadsPerChild</code>。</p>

<blockquote>
<p>需要额外注意的是，apache HTTP的子进程包含活动进程和正在关闭中的进程，至少会有一个进程来提供服务，至多有<code>MaxRequestWorkers</code>个正在关闭的进程（实际数量肯定少于这个值）。这种行为的产生原因有两种情况，一种是因为<code>MaxConnectionsPerChild</code>配置了一个子进程能处理的最大请求数，超过这个数目，该子进程就会停止处理新请求，然后被杀掉，重新创建一个新的子进程（为了有效的避免内存泄漏）。另外一种是因为空闲线程的数量超过了<code>MaxSpareThreads</code>配置的数目，触发了自动调节机制。如果希望关闭这种行为，可以将<code>MaxConnectionsPerChild</code>设置为0，然后将<code>MaxSpareThreads</code>和<code>MaxRequestWorkers</code>设置为同样的值。</p>
</blockquote>

<h3>1.3 <code>event</code></h3>

<p><code>event</code> MPM旨在通过将一些处理工作传递给侦听器线程从而释放工作线程以服务新请求的方式，来允许同时处理更多请求。</p>

<h4><strong>与<code>worker</code>的关系</strong></h4>

<p><code>event</code>是基于<code>worker</code>的。一个控制进程作为父进程来启动子进程，每个子进程创建固定数量的处理请求的线程以及一个监听线程，监听线程会监听请求连接，并将它们转交给处理请求的线程来处理。</p>

<h4><strong>配置重点</strong></h4>

<p><code>event</code>与<code>worker</code>配置基本一致，只是多了<code>AsyncRequestWorkerFactor</code>。</p>

<h4><strong>工作原理</strong></h4>

<p><code>event</code> MPM致力于在HTTP中的keepalive问题。</p>

<p>在客户端完成第一次请求后，它可以保留当前的连接而不关闭它，在相同的连接上发送接下来的请求，从而节省了TCP连接的信号交换成本。然而apache HTTP会留出一个完整的进程/线程来等待客户端的请求，这样相当于将其闲置，只为等待。为了解决这个问题，<code>event</code> MPM在每个子进程中使用指定的监听线程来掌控所有的监听sockets、所有处于Keepalive状态的sockets、处理程序和协议过滤器完成工作的sockets和唯一剩下发送给客户端的sockets。</p>

<p>这种新架构，使用了非阻塞sockets和APR提供的现代内核特性（比如linux的epoll）。
单个进程/线程块可以处理的连接总数由<code>AsyncRequestWorkerFactor</code>配置限定。</p>

<blockquote>
<p>更多event相关的原理，可详细参照<a href="https://httpd.apache.org/docs/2.4/mod/event.html">apache httpd event</a>。实践总结apahce(event) &lt;= nginx + apache(worker)，<code>event</code>唯一的作用是比<code>worker</code>节省资源，可以用更少的线程处理同样多的请求（超过线程能力的连接被放到队列中）。</p>
</blockquote>

<h2>2. MPM配置</h2>

<h3>2.1 常用MPM配置</h3>
<pre class="chroma"><span class="c1"># prefork MPM</span>
<span class="c1"># StartServers: number of server processes to start</span>
<span class="c1"># MinSpareServers: minimum number of server processes which are kept spare</span>
<span class="c1"># MaxSpareServers: maximum number of server processes which are kept spare</span>
<span class="c1"># MaxRequestWorkers: maximum number of server processes allowed to start</span>
<span class="c1"># MaxConnectionsPerChild: maximum number of connections a server process serves before terminating</span>
&lt;IfModule mpm_prefork_module&gt;
    StartServers             <span class="m">5</span>
    MinSpareServers          <span class="m">5</span>
    MaxSpareServers         <span class="m">10</span>
    MaxRequestWorkers      <span class="m">250</span>
    MaxConnectionsPerChild   <span class="m">0</span>
&lt;/IfModule&gt;

<span class="c1"># worker MPM</span>
<span class="c1"># StartServers: initial number of server processes to start</span>
<span class="c1"># MinSpareThreads: minimum number of worker threads which are kept spare</span>
<span class="c1"># MaxSpareThreads: maximum number of worker threads which are kept spare</span>
<span class="c1"># ThreadsPerChild: constant number of worker threads in each server process</span>
<span class="c1"># MaxRequestWorkers: maximum number of worker threads</span>
<span class="c1"># MaxConnectionsPerChild: maximum number of connections a server process serves before terminating</span>
&lt;IfModule mpm_worker_module&gt;
    StartServers             <span class="m">3</span>
    MinSpareThreads         <span class="m">75</span>
    MaxSpareThreads        <span class="m">250</span> 
    ThreadsPerChild         <span class="m">25</span>
    MaxRequestWorkers      <span class="m">400</span>
    MaxConnectionsPerChild   <span class="m">0</span>
&lt;/IfModule&gt;

<span class="c1"># event MPM</span>
<span class="c1"># StartServers: initial number of server processes to start</span>
<span class="c1"># MinSpareThreads: minimum number of worker threads which are kept spare</span>
<span class="c1"># MaxSpareThreads: maximum number of worker threads which are kept spare</span>
<span class="c1"># ThreadsPerChild: constant number of worker threads in each server process</span>
<span class="c1"># MaxRequestWorkers: maximum number of worker threads</span>
<span class="c1"># MaxConnectionsPerChild: maximum number of connections a server process serves</span>
<span class="c1">#                         before terminating</span>
&lt;IfModule mpm_event_module&gt;
    StartServers             <span class="m">3</span>
    MinSpareThreads         <span class="m">75</span>
    MaxSpareThreads        <span class="m">250</span>
    ThreadsPerChild         <span class="m">25</span>
    MaxRequestWorkers      <span class="m">400</span>
    MaxConnectionsPerChild   <span class="m">0</span>
&lt;/IfModule&gt;
</pre>
<blockquote>
<p><code>MaxRequestWorkers</code> 在 apache HTTP 2.3.13 之前被称为 <code>MaxClients</code>
<code>MaxConnectionsPerChild</code> 在apache HTTP 2.3.9 之前被称为<code>MaxRequestsPerChild</code></p>
</blockquote>

<h3>2.2 配置项详解</h3>

<h4><strong><code>StartServers</code>(event, worker, prefork)</strong></h4>

<p>指定服务器启动时建立的子进程数量。</p>

<p><code>prefork</code>MPM下默认为5。</p>

<p><code>worker</code>和<code>event</code>MPM下默认是3.</p>

<hr />

<h4><strong><code>MinSpareServers</code>(prefork)</strong></h4>

<p>指定空闲子进程的最小数量，默认为5。</p>

<p>如果当前空闲子进程数少于<code>MinSpareServers</code> ，那么Apache将创建一个子进程，一秒后，创建两个，一秒后，创建四个，就这样持续增加，最大一次创建32个。就这样创建进程直到达到<code>MinSpareServers</code>指定的数值。</p>

<hr />

<h4><strong><code>MaxSpareServers</code>(prefork)</strong></h4>

<p>设置空闲子进程的最大数量，默认为10。</p>

<p>如果当前有超过<code>MaxSpareServers</code>数量的空闲子进程，那么父进程将杀死多余的子进程。此参数不要设的太大。如果你将该指令的值设置为等于或小于<code>MinSpareServers</code>，Apache将会自动将其修改成<code>MinSpareServers+1</code>。</p>

<hr />

<h4><strong><code>MinSpareThreads</code>(event, worker)</strong></h4>

<p>指定空闲子线程的最小数量，默认为75。</p>

<p><code>worker</code>和<code>event</code>在服务级别来处理空闲子线程，当空闲子线程小于最小值，Apache会创建子进程，直到空闲子线程大于<code>MaxSpareThreads</code>。</p>

<hr />

<h4><strong><code>MaxSpareThreads</code>(event, worker)</strong></h4>

<p>指定空闲子线程的最大数量，默认为250。</p>

<p><code>worker</code>和<code>event</code>在服务级别来处理空闲子线程，当空闲子线程超过了最大值，Apache会杀死子进程，直到空闲子线程小于<code>MaxSpareThreads</code>。</p>

<hr />

<h4><strong><code>ThreadsPerChild</code>(event, worker)</strong></h4>

<p>指定每个子进程要创建多少个子线程，默认为25。</p>

<p><code>ThreadsPerChild</code>不可以超过<code>ThreadLimit</code>。</p>

<hr />

<h4><strong><code>MaxRequestWorkers</code>(event, worker, prefork)</strong></h4>

<p>指定同一时间客户端最大接入请求的数量。</p>

<p><code>prefork</code>MPM下，默认为256。任何超过<code>MaxRequestWorkers</code>限制的请求都将进入等候队列，一旦一个链接被释放，队列中的请求将得到服务。要增大这个值，你必须同时增大<code>ServerLimit</code>。</p>

<p><code>worker</code>和<code>event</code>MPM下，默认为<code>16(ServerLimit)*25(ThreadsPerChild)</code>。如果<code>MaxRequestWorkers</code>和<code>ThreadsPerChild</code>需要的子进程数超过16，同时应该提高<code>ServerLimit</code>。</p>

<hr />

<h4><strong><code>MaxConnectionsPerChild</code>(event, worker, prefork)</strong></h4>

<p>每个子进程在其生存期内允许处理的最大请求数量，默认为0，即子进程永远不会结束。</p>

<p>到达MaxRequestsPerChild的限制后，子进程将会结束。将MaxRequestsPerChild设置成非零值有两个好处：</p>

<ol>
<li>可以防止(偶然的)内存泄漏无限进行，从而耗尽内存。</li>
<li>给进程一个有限寿命，从而有助于当服务器负载减轻的时候减少活动进程的数量。</li>
</ol>

<hr />

<h4><strong><code>ServerLimit</code>(event, worker, prefork)</strong></h4>

<p>在<code>prefork</code>MPM下，指定Apache httpd 进程声明周期内<code>MaxRequestWorkers</code>可配置的最大值。</p>

<p>在<code>worker</code>和<code>event</code>MPM下，和<code>ThreadLimit</code>组合在一起，指定Apache httpd 进程声明周期内<code>MaxRequestWorkers</code>可配置的最大值。</p>

<p>需要重点关注的是，当设定远超过需要的值时，未使用的额外的共享内存也会被分配占用。如果<code>ServerLimit</code>和<code>MaxRequestWorkers</code>设定为超过系统可以支撑的值时，Apache httpd不会启动或者会不稳定。</p>

<p>在<code>prefork</code>MPM下，只有当<code>MaxRequestWorkers</code>需要设定超过其默认值（256）时，才需要设定<code>ServerLimit</code>。不要将<code>ServerLimit</code>的值设置为高于你可能希望将 <code>MaxRequestWorkers</code> 设置为的值。</p>

<p>在<code>worker</code>和<code>event</code>MPM下，只有当 <code>MaxRequestWorkers</code>/<code>ThreadsPerChild</code>需要大于默认值（16）时，才需要设定<code>ServerLimit</code>。</p>

<blockquote>
<p><code>ServerLimit</code>(prefork)在编译阶段，默认有个最大配置限制200000。如果希望可以配置的更大，则必须修改mpm源码中的<code>MAX_SERVER_LIMIT</code>，然后重新编译apache。</p>
</blockquote>

<hr />

<h4><strong><code>ThreadLimit</code>(event, worker)</strong></h4>

<p>指定 <code>ThreadsPerChild</code>可配置的最大值，默认值64。</p>

<p>需要重点关注的是，当设定远超过需要的值时，为使用的额外的共享内存也会被分配占用。如果<code>ThreadLimit</code>和<code>ThreadsPerChild</code>设定为超过系统可以支撑的值时，Apache httpd不会启动或者会不稳定。</p>

<blockquote>
<p><code>ThreadLimit</code>(worker)在编译阶段，默认有个最大配置限制20000(event 10000)。如果希望可以配置的更大，则必须修改mpm源码中的<code>MAX_THREAD_LIMIT</code>，然后重新编译apache。</p>
</blockquote>

<h2>3. apache模式的查看</h2>

<h3>3.1 常看当前模式</h3>

<p>如果apache已经安装，我们可以用以下命令查看当前模式。</p>
<pre class="chroma">httpd -l
</pre>
<p>若找到 <code>prefork.c</code> 则表示当前工作在<code>prefork</code>MPM，同理出现 <code>worker.c</code> 则工作在<code>worker</code> MPM。</p>

<p>如果apache还未安装，我们在编译的时候可以加入 <code>--with-pem=(prefork|worker)</code> 选项决定启用什么模式。</p>

<h3>3.2 切换模式</h3>
<pre class="chroma"><span class="c1"># a. 将当前的prefork模式启动文件改名</span>
mv httpd httpd.prefork

<span class="c1"># b. 将worker模式的启动文件改名</span>
mv httpd.worker httpd

<span class="c1"># c. 修改Apache配置文件</span>
vi /usr/local/apache2/conf/extra/httpd-mpm.conf
<span class="c1"># 找到里边的如下一段，可适当修改负载等参数：</span>
<span class="c1">#&lt;IfModule mpm_worker_module&gt;</span>
<span class="c1">#StartServers</span> 
<span class="c1">#MaxClients</span> 
<span class="c1">#MinSpareThreads</span> 
<span class="c1">#MaxSpareThreads</span> 
<span class="c1">#ThreadsPerChild</span> 
<span class="c1">#MaxRequestsPerChild</span> 
<span class="c1">#&lt;/IfModule&gt;</span>

<span class="c1"># d. 重新启动服务</span>
/usr/local/apache2/bin/apachectl restart
</pre>
<h2>4. 总结</h2>

<h3>4.1 为什么event和nginx都是用了epoll的原理，但是apache性能不如nginx呢？</h3>

<p>这是因为apache(event)的thread依赖kernel进行调度，有线程的上下文切换成本。但是nginx使用event驱动本身作为调度器，没有上下文切换成本。这也就是为什么<code>nginx+apache(worker)</code>比使用<code>apache(event)</code>更优的原因</p>

<h3>4.2 那么apache和nginx该如何选择呢？</h3>

<ul>
<li>如果是用很重的CGI应用，那么最佳实践是<code>nginx+apache(worker)+CGI</code>；</li>
<li>如果只是静态文件，那么就是<code>nginx</code>；</li>
<li>如果只是做一个proxy，那么就是<code>nginx --proxy-to-&gt; backend</code></li>
</ul>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="linux/advance/memory_03_general_memory_layout.html">内存: 进程内存布局 - 堆栈</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>01 Aug 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h3>0. 进程的常见内存布局(c/c++)</h3>

<p>进程是操作系统分配内存资源的最小单位，每个进程都有自己独立的内存布局（虚拟内存）。包含：</p>

<ul>
<li>stack: 保存function和local var</li>
<li>memory mapping: 保存大块的从文件映射的内存空间，用于加载代码库文件、共享内存等</li>
<li>heap: 程序动态使用的内存</li>
<li>data: 全局变量，分为初始化的(data segment，实际分配内存)和非初始化的(bss segment，实际未分配内存)</li>
<li>text: 保存运行的code</li>
</ul>

<blockquote>
<p>memory mapping的内存会统计在top命令的SHR字段，所以，这个字段统计的内存并不全是共享内存，也包含其他被映射的文件，例如代码库文件</p>
</blockquote>

<p>linux内核给每个进程一个独立的虚拟内存地址。这个虚拟内存的地址是连续的，虚拟内存又分为“用户空间”和“内核空间”。当进程在用户态的时候，只能访问“用户空间”，相反地，只有进程在内核态的时候，才能访问“内核空间”。虽然每个进程的内存空间都包含了“内核空间”，但其实它们是同一段物理内存，这样进程在进入内核态时，都能方便的访问内核态空间内存。</p>

<p>关于“用户空间”，它的结构，一般是从低地址开始依次为text、data、heap、memory mapping。然后stack是从高地址往下分配。
<img src="/static/images/docs/linux/advance/memory_layout.png" alt="" /></p>

<blockquote>
<p>通常情况下，频繁被执行的程序，其text一般是共享并且是只读的。例如gcc、shell、text editor等</p>

<p><a href="https://courses.engr.illinois.edu/cs225/sp2022/resources/stack-heap/">stack and heap</a></p>
</blockquote>

<h3>1. heap和stack的区别</h3>

<ul>
<li>stack由编译器管理，而heap由程序员自己控制，使用方便，但是有泄漏风险。</li>
<li>stack是由虚拟内存地址的高地址向下分配；而heap是由低地址向上分配。</li>
<li>stack的容量由系统预先定义，一般比较小；而heap则是受限于操作系统中有效的虚拟内存，一般比较大。</li>
<li>stack不会产生内存碎片，而heap会产生比较多的碎片。</li>
</ul>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="service/nginx/nginx_2.1.9.03_configuration_log.html">nginx: 配置 - 日志</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>16 May 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>1. 常用的log_format</h2>

<h3>1.1 记录post data</h3>

<p>简单说明就是，在proxy_pass,fastcgi_pass,uwsgi_pass和scgi_pass配置块中，可以使用<code>reqeust_body</code>这个内置变量来获取POST请求的post数据。</p>
<pre class="chroma">log_format logpost &#34;$request_body&#34;;
</pre>
<blockquote>
<p>其他限制见官方文档：<a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body">built in var: request_body</a></p>

<p>注意：当nginx作为web tunnel，客户端使用CONNECT来访问时，使用这个配置无法获取预期值。</p>
</blockquote>

<h3>1.2 记录upstream的响应请求的server地址</h3>
<pre class="chroma">log_format logupstream &#34;$upstream_addr&#34;;
</pre>
<blockquote>
<p><a href="https://nginx.org/en/docs/http/ngx_http_upstream_module.html#var_upstream_addr">module ngx_http_upstream_module var: upstream_addr</a></p>

<p>注意：当nginx作为web tunnel，客户端使用CONNECT来访问时，使用这个配置无法获取预期值。</p>
</blockquote>

<h2>2. 问题</h2>

<h3>2.1 内置的log_format格式</h3>

<p>在nginx.conf中添加如下配置</p>
<pre class="chroma">log_format  combined  &#39;$remote_addr - $remote_user [$time_local] &#39;
                       &#39;&#34;$request&#34; $status $body_bytes_sent &#39;
                       &#39;&#34;$http_referer&#34; &#34;$http_user_agent&#34;&#39;;
</pre>
<p><strong>报错信息</strong></p>
<pre class="chroma">nginx -t
2008/05/26 18:45:16 <span class="o">[</span>emerg<span class="o">]</span> 19875#0: <span class="s2">&#34;log_format&#34;</span> directive duplicate <span class="s2">&#34;log_format&#34;</span> name in /usr/local/nginx/conf/nginx.conf:26
</pre>
<p>大意是，我们重复定义了combined日志格式，但是我仔细检查了整个nginx.conf，以及所有include的配置文件，都没有找到其他的combined这个log_format配置项。</p>

<p><strong>原因解析</strong>
<a href="http://mailman.nginx.org/pipermail/nginx/2008-May/005214.html">nginx邮件列表关于此问题的参考链接</a><br />
原来&rdquo;combined&rdquo; log_format 是在nginx的源码中已经定义过的，我重新去再次定义，实属画蛇添足，当然软件会提示我重复定义了。</p>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="linux/advance/network_tunnel-ipip.html">网络: 隧道 - IPIP</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>12 May 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>0. 隧道技术</h2>

<p>隧道技术是一种通过使用互联网络的基础设施在网络之间传递数据的方式。 使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。 隧道协议将这些其他协议的数据帧或包重新封装在新的包头中发送。 新的包头提供了路由信息，从而使封装的负载数据能够通过互联网络传递。</p>

<h2>1. IPIP</h2>

<h3>1.1 简介</h3>

<p>IPIP是隧道技术中的一种，适合只负载一个IP流的情况。</p>

<h2>2. IPIP实操</h2>

<h3>2.1 环境介绍</h3>

<ul>
<li>系统：fedora 36 aarch64</li>
</ul>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="linux/advance/network_ip-address.html">网络: IP - IP地址简介</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>11 May 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>1. IP地址简介</h2>

<ul>
<li><a href="https://www.iana.org/help/abuse-answers">IANA: Private Use IP</a></li>
<li><a href="https://www.avast.com/c-ip-address-public-vs-private">avast: public ip vs private ip</a></li>
</ul>

<h3>1.1 IP地址类型</h3>

<p>目前有两种IP网段类型，IPV4和IPV6。</p>

<h3>1.2 IP地址格式</h3>

<p>其中IPV4从1983年1月1日开始使用，直至今日依然被广泛使用。IPV4的格式是用&rdquo;.&ldquo;分隔开的四段数字，每段数字的取值范围从0-255，于是IPV4的地址范围从0.0.0.0到255.255.255.255。</p>

<p>而IPV6是从1999年开始部署，IPV6的地址是128位数字，通常使用十六进制字符表示，例如“2001:db8::abc:587”</p>

<h3>1.3 IP地址分配</h3>

<p>IP地址的分配和管理，是以Internet Assigned Numbers Authority (IANA)为中心，其与5个Regional Internet Registries (RIRs)合作来管理。</p>

<p>RIR：</p>

<ul>
<li>AfriNIC (Africa and parts of the Indian Ocean)</li>
<li>APNIC (Asia/Pacific Region)</li>
<li>ARIN (North America and parts of the Caribbean)</li>
<li>LACNIC (Latin America and parts of the Caribbean)</li>
<li>RIPE NCC (Europe, the Middle East and Central Asia)</li>
</ul>

<p>RIR是实际的ip分配机构，它们将ip网段分配给不同的ISP。而IANA则作为一个顶层的注册机构，例如下面这条注册信息</p>
<pre class="chroma">123/8   APNIC   2006-01 whois.apnic.net ALLOCATED
</pre>
<p>这代表了 123.0.0.0 - 123.255.255.255 在2006年1月分配给了APNIC。如果希望知道这个网段中的一段子网段分配给了谁，需要在whois.apnic.net中查询。</p>

<p>IANA只记录以下信息：</p>

<ul>
<li>已分配给 RIR 或其他用户的IP地址</li>
<li>保留用于特殊用途的那些IP地址</li>
<li>那些还没有被分配，留作以后分配和使用的</li>
</ul>

<blockquote>
<ul>
<li>特殊用途的ip地址在IANA显式已经被注册</li>
<li>IANA保留了192.0.32.0 - 192.0.47.255自用</li>
</ul>
</blockquote>

<h2>2. 特殊用途的地址</h2>

<h3>2.1 私有IP地址</h3>

<p>这些私有IP地址，可以被任何人使用，无需任何其他人授权。同时，这些地址也永远不可能在互联网上可见。</p>
<pre class="chroma">10.0.0.0 - 10.255.255.255     (10.0.0.0/8)
172.16.0.0 - 172.31.255.255   (172.16.0.0/12)
192.168.0.0 - 192.168.255.255 (192.168.0.0/16)
</pre>
<blockquote>
<p>由上至下，也被成为ABC三类私有网段。详情见<a href="https://www.rfc-editor.org/rfc/rfc1918.html">RFC1918</a></p>
</blockquote>

<h3>2.2 自动配置的IP地址</h3>
<pre class="chroma">169.254.0.0 - 169.254.255.255
</pre>
<p>用于一个联网设备需要ip地址，却没有被分配静态ip，且无法通过dhcp获取到ip时，自动给这个联网设备分配的一个地址。避免出现网络设备没有ip的情况，但需要注意，这个ip的流量会被限制在本地网络。</p>

<h3>2.3 回环网络IP地址</h3>
<pre class="chroma">127.0.0.0 - 127.255.255.255 (127.0.0.0/8)
</pre>
<p>用于代表设备本身的网络地址，最常用的是127.0.0.1。</p>

<h3>2.4 多播地址</h3>
<pre class="chroma">224.0.0.0 - 239.255.255.255
</pre>
<p>被预留用于在 Internet 中提供多播服务的特殊目的</p>

<h3>2.5 共享地址段</h3>
<pre class="chroma">100.64.0.0/10
</pre>
<p>用于运营商给用户提供的NAT解决方案</p>

<p>其他的还有IANA预留给美国政府机构的地址，详细内容可以查阅<a href="https://www.iana.org/assignments/ipv4-address-space/ipv4-address-space.xml#note1">iana ipv4 ip address space registry</a></p>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="linux/advance/bash_02_00_login_shell_vs_non_login_shell.html">bash: login shell vs non-login shell</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>02 May 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h3>1. login shell和non-login shell是什么？</h3>

<p>login shell是<code>参数0</code>以<code>&quot;-&quot;</code>开头，或者使用<code>--login(-l)</code>选项启动的shell。</p>

<p>non-login shell是除了login shell之外的shell。</p>

<blockquote>
<ul>
<li><a href="https://help.gnome.org/users/gnome-terminal/stable/pref-login-shell.html.en">gnome pages</a></li>
<li><a href="https://linux.die.net/man/1/bash">bash manual docs</a> 查看Invocation部分</li>
</ul>
</blockquote>

<h3>2. 如何区分login shell和non-login shell？</h3>

<p>根据login shell的介绍说明可知，我们可以查看login shell的<code>参数0</code>或根据启动选项中是否包含<code>login</code>来判断</p>
<pre class="chroma"><span class="c1"># METHOD 1，根据参数0是否以&#34;-&#34;开头来判断</span>
<span class="nb">echo</span> <span class="nv">$0</span>
-bash

<span class="c1"># METHOD 2，使用SHELLOPT来判断（这个一定准确，推荐）</span>
<span class="nb">shopt</span> login_shell
login_shell       on

<span class="nb">shopt</span> -q login_shell <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s1">&#39;Login shell&#39;</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s1">&#39;Not login shell&#39;</span>
Login shell
</pre>
<blockquote>
<p>方法1中，参数0不以&rdquo;-&ldquo;开头时，也不一定不是login shell，是因为还有部分是通过&rdquo;&ndash;login&rdquo;选项来启动的。所以推荐用方法2。</p>
</blockquote>

<h3>3. 如何创建login shell和non-login shell？</h3>

<p><strong>创建login shell</strong></p>

<ul>
<li>通过本地或者远程的连接，使用用户名和密码登录获得的第一个shell</li>
<li>通过<code>bash</code>或<code>sh</code>加上<code>--login(-l)</code>参数启动shell</li>
<li>使用<code>sudo -i</code>或<code>su -</code></li>
</ul>

<p><strong>创建non-login shell</strong></p>

<ul>
<li>未使用账号密码登录，直接使用<code>bash</code>或<code>sh</code>命令，无<code>--login(-l)</code>参数启动shell</li>
<li>crond中创建任务，默认是non-login shell，但是可以通过显式使用<code>bash</code>或<code>sh</code>命令加上<code>--login(-l)</code>参数，例如<code>bash(or sh) -l -c &quot;command&quot;</code>来创建login-shell。</li>
</ul>

<blockquote>
<p>这里暂时不讨论图形界面</p>
</blockquote>

<h3>4. 为什么需要有login shell和non-login shell？</h3>

<p>没有找到确切的原因，但是根据网上的讨论，一个相对靠谱的说法是，因为login shell和non-login shell加载的start up文件不同（详细的看man文档），有些登录时需要执行的任务，如果在每次执行其他子shell的时候都执行一遍，这样任务太重。所以才创建了这种non-login shell，避免每次创建子shell环境都会执行一遍那些任务。</p>

<blockquote>
<p><a href="https://unix.stackexchange.com/questions/324359/why-a-login-shell-over-a-non-login-shell">stackexchange answer</a></p>
</blockquote>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="linux/advance/rlimit_fd_02_commands_to_check_current_status.html">rlimit fd: 状态查看命令</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>01 May 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h3>0. fd(文件描述符)限制的项目说明</h3>

<ul>
<li><strong><code>/proc/sys/fs/file-max</code></strong>是linux内核级别的设定，影响的是linux系统上所有进程可以打开的文件数上限</li>
<li><strong><a href="/linux/advance/rlimit_ulimit_01_introduce.html"><code>ulimit</code></a></strong>是用户或用户组级别，通过PAM登录的login shell，fork出的进程可以打开的文件数上限；</li>
<li><strong><code>/proc/sys/fs/file-nr</code></strong>是系统级别当前打开文件状态</li>
<li><strong><code>/proc/$pid/limits</code></strong>是指定进程的资源限制上限</li>
</ul>

<blockquote>
<p>参考文档:<br />
<a href="https://unix.stackexchange.com/questions/55319/are-limits-conf-values-applied-on-a-per-process-basis">ulimit设定的是每个进程的属性，而不是该用户所有进程的总限制</a><br />
<a href="https://unix.stackexchange.com/questions/447583/ulimit-vs-file-max">ulimit vs file-max</a><br />
<a href="https://stackoverflow.com/questions/6180569/need-to-calculate-optimum-ulimit-and-fs-file-max-values-according-to-my-own-se">如何计算最大文件打开数应该设定多少</a></p>
</blockquote>

<h3>1. 系统级别，文件打开数状态查看</h3>
<pre class="chroma"><span class="c1"># 查看linux内核级别的文件描述符上限</span>
cat /proc/sys/fs/file-max
<span class="m">97984</span>

<span class="c1"># 查看目前系统使用的文件描述符数量</span>
cat /proc/sys/fs/file-nr
<span class="m">512</span> <span class="m">0</span> <span class="m">97984</span>
<span class="c1"># 512   -&gt; 分配并使用的文件描述符数量</span>
<span class="c1"># 0     -&gt; 分配却未使用的文件描述符数量</span>
<span class="c1"># 97984 -&gt; 内核级别的最大文件描述符数量</span>
</pre>
<h3>2. 查看特定进程的最大文件打开数状态</h3>
<pre class="chroma">cat /proc/397/limits <span class="p">|</span> grep <span class="s2">&#34;open files&#34;</span>
Max open files            <span class="m">2048</span>                 <span class="m">2048</span>                 files
</pre>
        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="linux/advance/rlimit_fd_03_how_linux_limit_fd.html">rlimit fd: linux中如何管理fd</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>30 Apr 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>0. 总览</h2>

<p>上一篇<a href="/linux/advance/rlimit_fd_01_file_descriptor_brief_introduction.html">文件描述符简明介绍</a>中有介绍fd是什么，那么linux中是如何管理它的呢？</p>

<p>根据上篇文章，我们可知，fd的实际使用是绑定到每个进程上的。</p>

<p>因为linux上创建进程，其实是通过拷贝的方式来实现的，区别只是在于PID、PPID、某些资源和统计量（例如挂起的信号量），大部分的task_struct(fd表所在的数据结构)中的数据没有变化，相当于是直接继承了，<strong>所以fd的限制理论上，是直接继承的父进程的fd的限制</strong>。</p>

<p>但是也会有其他的管理工具或者方法可以让子进程改变继承的fd限制。总结来讲有以下几种方式：</p>

<ol>
<li>login-shell通过ulimit来设定登录用户或登录用户组的fd限制（或non-login-shell通过在启动脚本中显式调用ulimit命令）</li>
<li>container通过container management来设定fd限制</li>
<li>systemd管理的service通过systemd的配置来设定fd限制</li>
<li>程序本身调用系统调用来修改fd限制</li>
</ol>

<p>除了默认的从父进程继承的形式之外，其他所有改变fd限制的方式底层都是通过相关的几个系统调用（后面细讲）来实现的。</p>

<blockquote>
<p>只有root才可以调高hard limit，其他的用户只可以调整soft limit（不可以超过hard limit）</p>
</blockquote>
<pre class="chroma">┌────────────┐ ┌────────┐ ┌─────┐     ┌────┐ ┌─────┐ ┌─────┐     ┌─────────┐
│init/systemd│ │services│ │shell│     │sshd│ │crond│ │login│     │container│
└────────┬───┘ └────┬───┘ └───┬─┘     └──┬─┘ └──┬──┘ └───┬─┘     └────┬────┘
         │          │    (opti│onal)     └──────┴────────┤            │ 
         │          │         └─────────────┐            │            │
         │          │                       │           PAM           │
         │          ├─sysvinit scripts──────┤            │            │
         │          │   (optional)          │            │            │
         │          │                       │            │            │
         │          ├─systemd units─┐       │            │            │
         │          │               │       │            │            │
         │       ┌──▼───┐   ┌───────▼─┐ ┌───▼──┐ ┌───────▼──────┐ ┌───▼────────┐
         │       │ hard │   │ systemd │ │ulimit│ │ limits.conf  │ │ container  │
         └──────►│ code │   │         │ │(cmd) │ │ pam_limit.so │ │ management │
                 └──┬───┘   └────┬────┘ └───┬──┘ └───────┬──────┘ └──────┬─────┘
                    │            │          │            │               │
                    └────────────┴──────────┴───┬────────┴───────────────┘
                                          SYSTEM│CALL
            DEFAULT                             │
   ┌─────────────────────────┬──────────────────▼──────┐
   │                         │                         │
   │     inherit from        │    getrlimit prlimit    │
   │     parent process      │    setrlimit rlimit     │
   │                         │                         │
   ├─────────────────────────┴─────────────────────────┤
   │                                                   │
   │                      KERNEL                       │
   │                                                   │
   └───────────────────────────────────────────────────┘
</pre>
<h2>1. 资源限制(rlimit)的系统调用：getrlimit, setrlimit, prlimit</h2>

<ul>
<li><p>和资源限制（包含fd）系统调用相关的数据结构：<code>rlimit</code>（resource limit）</p></li>

<li><p>和资源限制（包含fd）相关的系统调用</p></li>
</ul>
<pre class="chroma"><span class="c1">// 获取rlimit
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">getrlimit</span><span class="p">(</span><span class="kt">int</span> <span class="n">resource</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">rlim</span><span class="p">)</span><span class="p">;</span>

<span class="c1">// 设定rlimit
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">setrlimit</span><span class="p">(</span><span class="kt">int</span> <span class="n">resource</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">rlim</span><span class="p">)</span><span class="p">;</span>

<span class="c1">// 设定其他进程的rlimit
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">prlimit</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resource</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">new_limit</span><span class="p">,</span>
                   <span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">old_limit</span><span class="p">)</span><span class="p">;</span>
</pre>
<h2>2. 子进程继承父进程的fd限制</h2>

<h3>2.1 简单fork进程，继承测试和hard code硬编程fd限制测试</h3>

<p>准备一个简单的测试c程序<code>limit.c</code>，为排除ulimit的影响，修改父进程的rlimit值为和ulimit不同的值，看子进程是否继承</p>
<pre class="chroma"><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;sys/resource.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span><span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">c_pid</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rlimit</span> <span class="n">p_rlim</span><span class="p">,</span> <span class="n">c_rlim</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">(</span><span class="p">)</span><span class="o">=</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">fork done</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">c_pid</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">c_pid</span> <span class="o">!</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// change parent pid&#39;s rlimit
</span><span class="c1"></span>        <span class="n">p_rlim</span><span class="p">.</span><span class="n">rlim_cur</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
        <span class="n">p_rlim</span><span class="p">.</span><span class="n">rlim_max</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">setrlimit</span><span class="p">(</span><span class="n">RLIMIT_NOFILE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p_rlim</span><span class="p">)</span> <span class="o">=</span><span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">getrlimit</span><span class="p">(</span><span class="n">RLIMIT_NOFILE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p_rlim</span><span class="p">)</span> <span class="o">=</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">Parent limits -&gt; soft limit= %ld </span><span class="se">\t</span><span class="s"> hard limit= %ld </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
                <span class="n">p_rlim</span><span class="p">.</span><span class="n">rlim_cur</span><span class="p">,</span> 
                <span class="n">p_rlim</span><span class="p">.</span><span class="n">rlim_max</span><span class="p">)</span><span class="p">;</span>
            <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">Parent pid = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">getrlimit</span><span class="p">(</span><span class="n">RLIMIT_NOFILE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c_rlim</span><span class="p">)</span> <span class="o">=</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">Child limits -&gt; soft limit= %ld </span><span class="se">\t</span><span class="s"> hard limit= %ld </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
                <span class="n">c_rlim</span><span class="p">.</span><span class="n">rlim_cur</span><span class="p">,</span> 
                <span class="n">c_rlim</span><span class="p">.</span><span class="n">rlim_max</span><span class="p">)</span><span class="p">;</span>
            <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">Child pid = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><pre class="chroma"><span class="c1"># 为排除ulimit的影响，我们先设定ulimit的限制为和父进程的rlimit不同的值</span>
<span class="nb">ulimit</span> -n <span class="m">1024</span>

<span class="c1"># compile测试程序并运行</span>
gcc limit.c -o limit

./limit
fork <span class="k">done</span>
Child limits -&gt; soft <span class="nv">limit</span><span class="o">=</span> <span class="m">1024</span>    hard <span class="nv">limit</span><span class="o">=</span> <span class="m">1024</span> 
Child <span class="nv">pid</span> <span class="o">=</span> <span class="m">246</span>
Parent limits -&gt; soft <span class="nv">limit</span><span class="o">=</span> <span class="m">512</span>    hard <span class="nv">limit</span><span class="o">=</span> <span class="m">512</span> 
Parent <span class="nv">pid</span> <span class="o">=</span> <span class="m">245</span>
</pre>
<p>可以看出，limit（子）的fd限制继承自limit（父），然后limit（父）可以通过hard code把fd限制手动修改</p>

<blockquote>
<p><strong>注意：</strong>程序设定的值不可以超过父进程bash的值，也就是ulimit命令设定的hard limit的值，否则会有如下报错</p>
<pre class="chroma">strace ./limit

......

setrlimit<span class="o">(</span>RLIMIT_NOFILE, <span class="o">{</span><span class="nv">rlim_cur</span><span class="o">=</span>1025, <span class="nv">rlim_max</span><span class="o">=</span>1025<span class="o">}</span><span class="o">)</span> <span class="o">=</span> -1 EPERM <span class="o">(</span>Operation not permitted<span class="o">)</span>
--- SIGSEGV <span class="o">{</span><span class="nv">si_signo</span><span class="o">=</span>SIGSEGV, <span class="nv">si_code</span><span class="o">=</span>SEGV_MAPERR, <span class="nv">si_addr</span><span class="o">=</span>0x80cde390<span class="o">}</span> ---
+++ killed by SIGSEGV +++
Segmentation fault
</pre></blockquote>

<h2>3. 通过其他管理工具或者系统调用来修改fd限制</h2>

<h3>3.1 ulimit</h3>

<p>详细内容见：<a href="/linux/advance/rlimit_ulimit_01_introduce.html">ulimit工具简明介绍：2.3</a></p>

<ul>
<li>sysvinit script是否受ulimit中的配置限制；答案：（未验证，猜测是否）</li>
<li>手动创建子shell(login shell 和 non-login shell)，是配置文件生效，还是继承的父进程的值？答案：继承父进程的值</li>
<li>crontab中的任务是否受ulimit中的配置限制；答案：收到<code>/etc/security/limits.conf</code>中的配置限制，前提是在pam中针对crond配置了pam_limits.so模块的对应配置</li>
</ul>

<h3>3.2 systemd</h3>

<p>详细内容见：<a href="/linux/advance/systemd_00_00_rlimit_settings.html">systemd 系统资源限制</a></p>

<h3>3.3 container management</h3>

<h4>3.3.1 docker</h4>

<h4>3.3.2 podman</h4>

<p>详细配置见<a href="/virtualization/container/podman_config_00_rlimit.html">podman config: 系统资源限制</a></p>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="linux/advance/rlimit_fd_01_file_descriptor_brief_introduction.html">rlimit: fd - 简明介绍</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>11 Apr 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>0. 什么是fd？</h2>

<p>FD的全称是 file descriptor 文件描述符。在介绍FD之前，我们先来了解几个问题。</p>

<h2>1. 关于fd的几个常见问题</h2>

<ol>
<li><p>在文件系统中，如果我和你都被允许访问一个文件，我们可以共享文件的数据吗？</p>

<p>答案是：yes。</p></li>

<li><p>如果两个进程在同一个文件上读取和写入，它们使用的是同样的文件偏移量吗？</p>

<p>答案是：no。</p></li>

<li><p>如果一个进程把同一个文件打开两次，它应该有一个fd还是有两个？在这种情况下，这两个打开共享同一个文件偏移量吗？</p>

<p>答案是：two，no，它们各自拥有自己的文件偏移量。</p></li>

<li><p>如果两个线程使用了同一个fd，它们用的是同一个文件偏移量吗？</p>

<p>答案是：yes。</p></li>

<li><p>如果一个父进程创造了一个子进程，子进程会继承父进程的fd吗？它们会不会使用同样的文件偏移量？</p>

<p>答案是：yes，yes</p></li>
</ol>

<h2>2. linux系管理fd时使用的数据结构</h2>

<p>先来说明几个事实：</p>

<ul>
<li>当一个进程使用open这个系统调用时，open的返回值是一个小的整数，这个整数被我们称之为fd。</li>
<li>每一个进程的fd都是以以下三个fd开始的：

<ul>
<li>标准输入：fd=0</li>
<li>标准输出：fd=1</li>
<li>标准错误：fd=2</li>
</ul></li>
</ul>

<p>在明确了以上事实后，问题是，我们需要什么样的数据结构（任何人都不会天真的认为仅靠一个小小的整数就可以代表一个fd，它背后肯定是链接着一个文件打开的详细信息）来管理fd？</p>

<h3>2.1 进程的fd表（<code>进程独享</code>）</h3>

<p>每一个进程，拥有一个单独的fd表。举个例子，当一个进程调用open系统调用打开一个文件时，open返回了3这个数字，代表了fd表中的第4个位置（0,1,2,3）。这个fd表同时包含了指向其他数据结构的指针。</p>

<h4>问题：我们可以在这个fd表中储存文件偏移量吗？</h4>

<p><strong>答案</strong>：不可以，因为在*nix系统中，创建进程的方式，是完整的拷贝一个进程的信息成为一个新的进程。如果文件偏移量存在进程的fd表里面，那么意味着新的进程会拥有一个单独的文件偏移量信息，当父进程的文件偏移量变动时，子进程感知不到，因为父子进程是各自独立的fd表。此时，如果我们希望在父子进程中共享文件打开信息时，由于父子进程各自独立的fd表，则无法实现这个目的。所以，更明智的做法是，将文件偏移量储存在另外一个地方，而父子进程的fd表同时来引用同一个文件偏移量，来达到文件信息共享的目的。</p>

<h3>2.2 所以，要如何储存文件偏移量呢？</h3>

<p>首先，每一个文件偏移量对应着一个open系统调用。所以，我们需要一个数据结构来储存每次open系统调用的结果。它就是<strong>文件打开表（file table OR open file table）</strong>（<code>所有进程共享</code>）。</p>

<p><strong>文件打开表</strong>中储存了如下信息：</p>

<ul>
<li>文件位置（文件偏移量）</li>
<li>引用数，当我们有两个或者多个fd引用同一个文件打开对象，需要记录这个数字</li>
<li>实际文件对象的引用，实际文件对象储存在内存中的一个数据结构中</li>
</ul>

<h3>2.3 最终，表示实际文件的储存在内存中的数据结构</h3>

<p>实际文件对象，我们称之为Vnode（virtual node），是文件在内存中的展现形式。而许许多多的实际文件对象，储存在一个<strong>Vnode table</strong>（<code>所有进程共享</code>）中。</p>

<p><strong>Vnode table</strong>中储存了如下信息：</p>

<ul>
<li>文件元数据的拷贝</li>
<li>在磁盘上定位到这个文件的储存块的方式（例如：inode）</li>
</ul>

<h2>3. 总结</h2>

<p><img src="/static/images/docs/linux/advance/fd-data-structure.jpg" alt="" /></p>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="service/haproxy/haproxy_01_config_log.html">haproxy: 配置和日志</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>24 Mar 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>1. haproxy配置</h2>

<h3>1) 常见的终止标志</h3>

<ul>
<li>PR，The proxy blocked the client&rsquo;s request, either because of an invalid HTTP syntax, in which case it returned an HTTP 400 error to the client, or because a deny filter matched, in which case it returned an HTTP 403 error.</li>
</ul>

<blockquote>
<p>其他的见参考文档：<a href="https://www.haproxy.org/download/1.4/doc/configuration.txt">haproxy 8.5 部分配置</a>，这里只列出我遇到过的</p>
</blockquote>

<h3>2) ACL配置</h3>

<p>大概的配置流程就是</p>

<ol>
<li>需要先定义一个测试标准</li>
<li>然后再根据上面的测试标准来做对应的动作</li>
</ol>

<p>格式：<code>acl &lt;aclname&gt; &lt;criterion&gt; [flags] [operator] &lt;value&gt; ...</code></p>

<blockquote>
<p>含义是创建了一个新的aclname(或者替代旧的)，然后可以根据这个aclname来执行对应的action</p>
</blockquote>

<p><strong>例如根据ip来源的配置</strong></p>
<pre class="chroma">acl in_src_ip_list src ip1 ip2 ip3 ...
tcp-request content accept if in_src_ip_list
tcp-request content reject
</pre>
<blockquote>
<p>其他详情见参考文档：<a href="https://www.haproxy.org/download/1.4/doc/configuration.txt">haproxy 7. 部分配置</a></p>
</blockquote>

        </div>

    </div>

  </div>
</body>

<footer>
    <div class="container">
        <div class="row footer-links">
            <div class="col-lg-2 col-sm-2">
                <h3>友情链接</h3>
                <ul>
                    <li><a href="">友链位招租</a></li>
                    <li><a href="">友链位招租</a></li>
                </ul>
            </div>
            <div class="col-lg-2 col-sm-2">
                <h3>没想好</h3>
                <ul>
                    <li><a href="">我爸没想好</a></li>
                    <li><a href="">我哥说我爸没想好</a></li>
                </ul>
            </div>
            <div class="col-lg-2 col-sm-2">
                <h3>Hooray</h3>
                <ul>
                    <li><a href="">Hooray</a></li>
                    <li><a href="">What are we Hooray For?</a></li>
                </ul>
            </div>
            <div class="col-lg-2 col-sm-2">
                <h3>前面的footer太浪了</h3>
                <ul>
                    <li><a href="">就是就是</a></li>
                    <li><a href="">偷偷的表示羡慕</a></li>
                </ul>
            </div>
            <div class="col-lg-4 col-sm-4">
                <h3>网站信息</h3>
                <a class="" href="" target="_blank"></a>
                <a class="" href="" target="_blank"></a>
                <a class="" href="" target="_blank"></a>
                <a class="" href="" target="_blank"></a>
                <div class="fine-print">
                    <p>网战由以下技术支撑</p>
                    <ul>
                        <li>Markdown Processor: <a href="https://github.com/russross/blackfriday/tree/v2">Blackfriday V2</a></li>
                        <li>Renderer Engine: <a href="https://github.com/Depado/bfchroma/">bfchroma</a></li>
                        <li>Syntax Highlighter: <a href="https://github.com/alecthomas/chroma">Chroma</a></li>
                        <li>Coding Language: <a href="https://go.dev/">Golang</a></li>
                        <li>Others: Markdown, HTML, CSS</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</footer>

</html>