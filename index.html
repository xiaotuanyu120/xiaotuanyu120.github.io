<!DOCTYPE html>
<html lang="zh-cmn">

<head>
    <title>XTY Blog | Linux Ops Docs | SRE | DEVOPS</title>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
    <link rel="stylesheet" href="/static/css/chroma.css">
    <link rel="stylesheet" href="/static/css/main.css">
</head>

<div class="blog-title">
	<div class="container">
		<div class="row">
			<div class="col-lg-12">
				<div>
					<a class="main-title" href="/">XTY的小站</a>
                </div>
                <div>
                    <a class="small-title" href="/">记录技术笔记和技术博客</a>
                </div>
			</div>
		</div>
	</div>
</div>

<body>
  <div class="container">

    <div class="col-lg-4 col-lg-offset-1 col-md-4 col-md-offset-1 col-sm-4 col-sm-offset-1">
	  <div id="sidebar">

		<h3>最新文章</h3>
          <ul>

            <li>
              <a href="/linux/advance/network_tcp-reset.html">网络: TCP - RST简介</a>
            </li>
            <li>
              <a href="/go/go/go_1.1.4_start_init.html">GO 1.1.4 入口函数和包初始化</a>
            </li>
            <li>
              <a href="/go/go/go_1.1.3_build.html">GO 1.1.3 构建应用</a>
            </li>
            <li>
              <a href="/go/go/go_1.1.2_proj_struct.html">GO 1.1.2 目录结构</a>
            </li>
            <li>
              <a href="/go/go/go_1.1.1_code_struct.html">GO 1.1.1 程序结构和编译</a>
            </li>
          </ul>

		<h3>文章分类</h3>
		  <ul>

            <li>
              <a href="/android/index.html">android</a>
            </li>
            <li>
              <a href="/bigdata/index.html">bigdata</a>
            </li>
            <li>
              <a href="/blockchain/index.html">blockchain</a>
            </li>
            <li>
              <a href="/blog/index.html">blog</a>
            </li>
            <li>
              <a href="/cloud/index.html">cloud</a>
            </li>
            <li>
              <a href="/cryptography/index.html">cryptography</a>
            </li>
            <li>
              <a href="/database/index.html">database</a>
            </li>
            <li>
              <a href="/devops/index.html">devops</a>
            </li>
            <li>
              <a href="/go/index.html">go</a>
            </li>
            <li>
              <a href="/ios/index.html">ios</a>
            </li>
            <li>
              <a href="/java/index.html">java</a>
            </li>
            <li>
              <a href="/linux/index.html">linux</a>
            </li>
            <li>
              <a href="/python/index.html">python</a>
            </li>
            <li>
              <a href="/service/index.html">service</a>
            </li>
            <li>
              <a href="/virtualization/index.html">virtualization</a>
            </li>
            <li>
              <a href="/web/index.html">web</a>
            </li>
          </ul>

      </div>
    </div>

    <div class="col-lg-7 col-md-7 col-sm-7">

        <div class="article-summary">
        <div class="article-title">
          <a href="linux/advance/network_tcp-reset.html">网络: TCP - RST简介</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>09 Dec 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<blockquote>
<p>主要参考资料：<a href="https://www.ietf.org/rfc/rfc3360.html">不恰当的RST是有害的</a></p>
</blockquote>

<h2>0. 前提</h2>

<p>探究TCP的RST状态之前，确保你对TCP的三次握手和四次挥手有一个基本的了解。<a href="/linux/advance/network_tcp-handshake-and-close.html">linux的三次握手和四次挥手浅谈</a></p>

<h2>1. TCP状态RST</h2>

<h3>1.1 RST是什么？以及它的用途是什么？</h3>

<p>RST(reset)是TCP头部中的一个标记位，用于重置一个tcp连接。恰当的做法是，接收端收到了一个对不存在的tcp连接的请求，tcp返回RST给请求方，告诉对方取消这次访问。</p>

<p>所以基本上的理解是，如果收到或者发送了一个RST，代表的基本上是，一个tcp连接已经关闭了，但是双方有一端因网络问题未同步到tcp连接已经关闭的状态，或者这个tcp连接关闭前的一个tcp包在tcp连接后延迟收到，为了快速同步状态，有一端主动回应RST告诉对方，之前的连接已经关闭了，如果还想通话，那么请开启一个新的请求。</p>

<h3>1.2 RST的实际应用情况</h3>

<p>根据<a href="https://www.ietf.org/rfc/rfc3360.html">不恰当的RST是有害的</a>中的说法，若抓包时，发现SYN的返回是一个RST，有时候可能是因为防火墙或者负载均衡使用了不恰当的RST的实现。大白话的意思就是，本来RST只是用于收到一个对不存在的tcp连接的请求的一个恰当回应用途，但是有些实现曲解了它的用途，将它用于对SYN握手的拒绝用途使用。所以实际RST的原因，需要抓包来观察。</p>

<h3>1.3 其他RST需要注意的地方</h3>

<p><a href="https://www.ietf.org/rfc/rfc3360.html">不恰当的RST是有害的</a>中还详细介绍了RST的历史，特别值得去看，会加深对RST的理解。</p>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="go/go/go_1.1.4_start_init.html">GO 1.1.4 入口函数和包初始化</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>27 Oct 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>1. 背景</h2>

<p>一个 Go 项目中有多个包，一个包有多个文件，同时每个包中又有多个常量、变量、各种函数和方法，那 Go 代码是使用什么顺序加载它们，又是从哪里开始执行的呢？</p>

<h2>2. <code>main.main</code> 函数：Go 应用的入口函数</h2>

<p>Go 语言中有一个特殊的函数 <code>main.main</code>，它是所有 Go 可执行应用的用户层执行逻辑的入口函数。</p>

<p><code>main.main</code> 函数没有参数，也没有返回值</p>
<pre class="chroma"><span class="kd">func</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello world&#34;</span><span class="p">)</span>
<span class="p">}</span>
</pre>
<p>Go 语言要求，可执行程序的main包，必须要包含main函数，否则 Go 编译器会报错</p>
<pre class="chroma">go build main.go 
<span class="c1"># command-line-arguments</span>
runtime.main_main·f: <span class="k">function</span> main is undeclared in the main package
</pre>
<p>另外值得注意的是，其他的包也可以拥有自己的main函数，但是不同包中的main函数只能在自己的包内部使用。</p>
<pre class="chroma"><span class="c1">// main.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;github.com/fakeuser/mod/pkg1&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello world&#34;</span><span class="p">)</span>
	<span class="nx">pkg1</span><span class="p">.</span><span class="nf">Main</span><span class="p">(</span><span class="p">)</span>
<span class="p">}</span>
</pre><pre class="chroma"><span class="c1">// pkg1/pkg1.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">pkg1</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">Main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main from pkg1&#34;</span><span class="p">)</span>
<span class="p">}</span>
</pre>
<p><code>pkg1</code> 包中的 <code>main</code> 函数，只能在 <code>pkg1</code> 包内部使用，这个例子就是在 <code>pkg1.Main</code> 这个函数中执行了它</p>
<pre class="chroma"><span class="c1"># What is the output?</span>
go run main.go
Hello world
main from pkg1
</pre>
<h2>3.  <code>init()</code> 函数：包初始化函数</h2>

<p><code>main.main</code> 虽然是用户层执行逻辑的入口函数，但是它并不是用户层被执行的第一个函数，<code>init</code> 函数才是。如果 <code>main</code> 包依赖的包中有 <code>init</code> 函数，或者 <code>main</code> 包自身有包含 <code>init</code> 函数，那么 Go 在这个程序初始化的时候，会自动调用它的 <code>init</code> 函数，因此，这些 <code>init</code> 函数的执行会在 <code>main.main</code> 函数之前。</p>

<p><code>init</code> 函数也是一个无参数无返回值的函数</p>
<pre class="chroma"><span class="kd">func</span> <span class="nf">init</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;print from init&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello world&#34;</span><span class="p">)</span>
<span class="p">}</span>
</pre>
<p>用户无法显式的调用 <code>init</code> 函数</p>
<pre class="chroma"><span class="kd">func</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">init</span><span class="p">(</span><span class="p">)</span>
<span class="p">}</span>
</pre>
<p>执行后会发生编译错误</p>
<pre class="chroma">go run main.go  
<span class="c1"># command-line-arguments</span>
./main.go:14:2: undefined: init
</pre>
<p>实际上，每一个 Go 包，或者每一个 Go 包中的源文件，都可以声明多个 <code>init</code> 函数。Go 编译器会特别对待 <code>init</code> 函数，因此不会发生函数名称重复的报错。</p>

<p>在初始化时，Go 会按照一定的次序，顺序并逐一的执行每个 <code>init</code> 函数。一般情况下，先传递给 Go 编译器的源文件中的 <code>init</code> 函数会被先执行；同一个源文件中的不同 <code>init</code> 函数，会根据声明的先后顺序依次执行。</p>

<h2>4. Go 包的初始化次序</h2>

<p>从程序逻辑结构角度来看，Go 包是程序逻辑封装的基本单元，每个包都可以理解为一个“自治”的、封装良好的、对外暴露有限接口的基本单元。一个 Go 程序就是一组包组成的，程序的初始化就是这些包的初始化。每个 Go 包还会有自己的依赖包、常量、变量、init函数等。</p>

<p>Go 包的初始化次序流程图
<img src="/static/images/docs/go/go_1.1.4_01.jpg" alt="" /></p>

<p>初始化次序注意点：</p>

<ul>
<li>每一个 Go 包的初始化内容都遵循 “常量 -&gt; 变量 -&gt; init 函数”的顺序</li>
<li>Go 包的初始化会采用“深度优先”原则</li>
<li>包内多个 <code>init()</code> 函数按照声明顺序初始化</li>
</ul>

<h3>4.1 Go 包初始化次序示例</h3>

<p>包之间的依赖关系如下</p>
<pre class="chroma"><span class="c1"># 依赖关系</span>
main &gt; pkg1 &gt; pkg3
     &gt; pkg2 &gt; pkg3
</pre>
<p><code>main.go</code></p>
<pre class="chroma"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="nx">_</span> <span class="s">&#34;github.com/fakeuser/mod/pkg1&#34;</span>
	<span class="nx">_</span> <span class="s">&#34;github.com/fakeuser/mod/pkg2&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">c</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">1</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">_</span>        <span class="p">=</span> <span class="nf">constInit</span><span class="p">(</span><span class="p">)</span>
	<span class="nx">s</span> <span class="kt">string</span> <span class="p">=</span> <span class="nf">varInit</span><span class="p">(</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main init()&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello world&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">varInit</span><span class="p">(</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main var init&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">constInit</span><span class="p">(</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;main const init&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>
</pre>
<p><code>pkg1/pkg1.go</code></p>
<pre class="chroma"><span class="kn">package</span> <span class="nx">pkg1</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="nx">_</span> <span class="s">&#34;github.com/fakeuser/mod/pkg3&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">c</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">1</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">_</span>        <span class="p">=</span> <span class="nf">constInit</span><span class="p">(</span><span class="p">)</span>
	<span class="nx">s</span> <span class="kt">string</span> <span class="p">=</span> <span class="nf">varInit</span><span class="p">(</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;pkg1 init()&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">varInit</span><span class="p">(</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;pkg1 var init&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">constInit</span><span class="p">(</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;pkg1 const init&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>
</pre>
<p><code>pkg2/pkg2.go</code></p>
<pre class="chroma"><span class="kn">package</span> <span class="nx">pkg2</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="nx">_</span> <span class="s">&#34;github.com/fakeuser/mod/pkg3&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">c</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">1</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">_</span>        <span class="p">=</span> <span class="nf">constInit</span><span class="p">(</span><span class="p">)</span>
	<span class="nx">s</span> <span class="kt">string</span> <span class="p">=</span> <span class="nf">varInit</span><span class="p">(</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;pkg2 init()&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">varInit</span><span class="p">(</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;pkg2 var init&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">constInit</span><span class="p">(</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;pkg2 const init&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>
</pre>
<p><code>pkg3/pkg3.go</code></p>
<pre class="chroma"><span class="kn">package</span> <span class="nx">pkg3</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">const</span> <span class="nx">c</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">1</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">_</span>        <span class="p">=</span> <span class="nf">constInit</span><span class="p">(</span><span class="p">)</span>
	<span class="nx">s</span> <span class="kt">string</span> <span class="p">=</span> <span class="nf">varInit</span><span class="p">(</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;pkg3 init()&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">varInit</span><span class="p">(</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;pkg3 var init&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">constInit</span><span class="p">(</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;pkg3 const init&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>
</pre>
<p>执行查看各个包的初始化顺序</p>
<pre class="chroma">go run main.go
pkg3 const init
pkg3 var init
pkg3 init<span class="o">(</span><span class="o">)</span>
pkg1 const init
pkg1 var init
pkg1 init<span class="o">(</span><span class="o">)</span>
pkg2 const init
pkg2 var init
pkg2 init<span class="o">(</span><span class="o">)</span>
main const init
main var init
main init<span class="o">(</span><span class="o">)</span>
Hello world
</pre>
<h2>5. init() 函数的用途</h2>

<h3>5.1 重置包级变量值</h3>

<h3>5.2 实现对包级变量的复杂初始化</h3>

<h3>5.3 在 init() 函数中实现注册模式</h3>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="go/go/go_1.1.3_build.html">GO 1.1.3 构建应用</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>26 Oct 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>1. 构建应用演进历史</h2>

<p>Go 语言的构建模式历经了三个迭代和演化过程，分别是最早期的GOPATH、1.5版本的 Vendor 机制，以及现在的 Go Module。</p>

<h3>1.1 GOPATH</h3>

<p>GOPATH 构建模式下，Go 语言通过环境变量 GOPATH 配置的路径下，搜寻第三方依赖包来构建应用。</p>

<p>在 GOPATH 构建模式下，解决依赖不存在的命令是 <code>go get ...</code>。不过这样只能获取执行命令当下时间依赖包的最新主线版本，而依赖包可能是不断演进的，因此，这种构建模式无法保证应用的可重现构建。</p>

<h3>1.2 Vendor</h3>

<p>Go 1.5 版本中引入了 Vendor 机制。本质就是在一个指定的 Vendor 目录中，将依赖包的特定版本拷贝进来。Go 编译器在编译时，优先查找 Vendor 目录中的依赖包，而不是直接去 GOPATH中寻找。</p>

<p>使用 Vendor 构建模式的最佳实践就是，将 Vendor 目录一起提交到应用代码库中。这样别人 clone 你的项目代码后，就可以实现可重现构建。</p>

<blockquote>
<p>需要注意的是，若希望使用 Vendor 模式，需要将 Go 项目置于 GOPATH 路径中的 src 目录中。否则 Go 编译器不会理会 Go 项目目录下的 Vendor 目录的。</p>
</blockquote>

<h3>1.3 Go Module</h3>

<p>Go 1.11 版本引入了 Go Module 机制，一个 Go Module 是一个 Go 包的集合，它是有版本的。</p>

<p>在 Go Module 机制下，通常一个 git 库就是一个 Go Module。每个 Go Module 项目根目录下会存在一个 go.mod 文件，Go Module 和 go.mod 是一一对应的关系。go.mod 文件所在的目录为 Go Module 的根目录，根目录和它的子目录的所有 Go 包都属于这个 Go Module。</p>

<blockquote>
<p>同时还有另外一个文件 go.sum，这个文件记录的是 Go Module 当前版本内容的哈希值。这是 Go Module 的一个安全机制，当下载一个 Go Module 后，go 会使用 go.sum 和下载内容的哈希值对比，通过验证其一致性来保证下载的内容不被恶意篡改。</p>
</blockquote>

<h2>2. 了解 Go Module</h2>

<h3>2.1 创建 Go Module 的步骤</h3>
<pre class="chroma"><span class="c1"># step 1. create Go Module</span>
<span class="c1"># syntax: &#34;go mod init [path/to/module]&#34;</span>
go mod init github.com/someuser/somemodule
<span class="c1"># OR &#34;go mod init myproject/service/module01&#34;</span>

<span class="c1"># step 2. auto anylysis dependencies</span>
<span class="c1"># syntax: &#34;go mod tidy&#34;</span>
go mod tidy
<span class="c1"># this command would auto download denpendency packages AND update go.mod</span>
<span class="c1"># default download dir is &#34;$GOPATH/pkg/mod&#34;, but it can been customized by modifying GOMODCACHE env var.</span>

<span class="c1"># step 3. build app</span>
<span class="c1"># syntax: &#34;go build&#34;</span>
go build
</pre>
<h3>2.2 深入 Go Module 机制</h3>

<h4><strong>2.2.1 Go Module 的语义导入版本机制</strong></h4>

<p>在 Go Module 构建模式下，一个符合 Go Module 要求的版本号，需满足语义版本规范的格式</p>
<pre class="chroma">v[major].[minor].[patch]
</pre>
<p>借助于语义版本规范格式，可以区分不同版本的先后顺序，以及它们的兼容性。</p>

<p>按照语义版本规范，主版本号不同的版本，是互不兼容的。而在主版本号相同的情况下，次版本号大都兼容之前的此版本号。补丁版本号不影响兼容性。</p>

<p>而且，Go Module 规定，如果一个包的新旧版本是兼容的，那么它们的包导入路径应该是相同的。</p>

<p>例如： v1.7.8 和 v1.8.1 的主版本号相同，那么它们的导入路径也相同；而 v1.8.1 和 v2.0.0 的主版本号不同，那么导入路径就可以按照如下处理</p>
<pre class="chroma"><span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;github.com/someuser/somemodule&#34;</span>
    <span class="nx">smv2</span> <span class="s">&#34;github.com/someuser/somemodule/v2&#34;</span>
<span class="p">)</span>
</pre>
<blockquote>
<p>因为v0.y.z一般情况下是在初期开发阶段的不稳定阶段，Go Module 将 v0.y.z 和 v1.y.z 做同等对待，它们具有同样的导入路径。</p>
</blockquote>

<h4><strong>2.2.2 Go Module 的最小版本选择原则</strong></h4>

<p>一般情况下，Go Module 只会依赖同一个版本的第三方包。但也存在 Go Module 下不同的包对同一个第三方包的不同版本存在依赖的情况，例如</p>
<pre class="chroma">main.go
go.mod
go.sum
internal
pkg1 // 依赖 3rd-module v1.1.0 [3rd-module latest version is v1.6.0]
pkg2 // 依赖 3rd-module v1.3.0
</pre>
<p>这种情况下，Go 会选择哪个版本的 <code>3rd-module</code> 来编译应用呢？</p>

<p>答案是 <code>v1.3.0</code> ，当前存在的许多主流编程语言，会通常会选择最新的版本，即上例中的 <code>v1.6.0</code>，依据是最新的版本通常情况下被认为更稳定和更安全。而 Go 的设计者认为，在考虑稳定和安全的基础上，也要尊重各个 Module 的诉求，<code>pkg1</code> 明确的要求依赖 <code>v1.1.0</code>，而 <code>pkg2</code> 明确的要求依赖 <code>v1.3.0</code>。<strong>Go 会在该项目依赖项的所有版本中，选择符合项目要求的“最小版本”</strong>。</p>

<p>拿前面的例子举例，符合项目要求的 <code>3rd-module</code> 的版本范围是 <code>v1.3.0 - v1.6.0</code>，所以最终 Go 的选择是 <code>v1.3.0</code>。</p>

<h2>3. Go Module 的常见操作</h2>

<h3>3.1 为当前 Go Module 增加一个依赖项</h3>
<pre class="chroma"><span class="c1"># step 1. add dependency to your code</span>

<span class="c1"># step 2. add dependency to go.mod</span>
<span class="c1"># method one</span>
go get github.com/someuser/somemodule
<span class="c1"># method two</span>
go mod tidy
</pre>
<h3>3.2 为已存在的依赖项升降级</h3>
<pre class="chroma"><span class="c1"># How to check module&#39;s version list?</span>
go list -m github.com/someuser/somemodule

<span class="c1"># How to downgrade from v1.8.0 to v1.7.0?</span>
<span class="c1"># update your code first !!!</span>
<span class="c1"># method one</span>
go get github.com/someuser/somemodule@v1.7.0
<span class="c1"># method two</span>
go mod edit -require<span class="o">=</span>github.com/someuser/somemodule@v1.7.0
go mod tidy

<span class="c1"># How to upgrade from v1.8.0 to v2.0.0?</span>
<span class="c1"># update your code first !!!</span>
<span class="c1"># method one</span>
go get github.com/someuser/somemodule/v2
</pre>
<h3>3.3 移除一个依赖</h3>
<pre class="chroma"><span class="c1"># Update your code first !!!</span>
<span class="c1"># delete &#34;import github.com/someuser/somemodule/v2&#34;</span>

<span class="c1"># Is it gone already? Check all modules</span>
go list -m all
...
github.com/someuser/somemodule/v2
...
<span class="c1"># its still there</span>

<span class="c1"># How to remove a dependency?</span>
go mod tidy
</pre>
<h3>3.4 特殊情况：如何使用 Vendor？</h3>

<p>在某些特殊场景，例如无法访问互联网的环境，或者一些内部的CI/CD中，可能会用到 Vendor 模式</p>
<pre class="chroma"><span class="c1"># How to Generate Vendor?</span>
go mod vendor
<span class="c1"># This command would</span>
<span class="c1"># - copy dependencies to vendor directory</span>
<span class="c1"># - maintain a file modules.txt in vendor directory</span>

<span class="c1"># How to Build in vendor mode?</span>
go build -mod<span class="o">=</span>vendor
</pre>
<blockquote>
<p>Go 1.14 及其以后的版本中，若 Go 项目中存在 vendor 目录，则会优先使用 vendor 模式来构建。除非使用 <code>go build -mod=mod</code>来指定 Go Module 构建模式。</p>
</blockquote>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="go/go/go_1.1.2_proj_struct.html">GO 1.1.2 目录结构</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>25 Oct 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>1. 几次目录结构的演进</h2>

<h3>1.1 Go 1.4 版本中，移除 pkg 和引入 internal</h3>

<p>Go 1.4 版本中删除了 pkg 这一中间层目录，并引入了 internal 目录。</p>

<p>出于简化层次的目的，原本<code>src/pkg/xxx</code>改为<code>src/xxx</code>。</p>

<p>出于分类和清晰用途的目的，引入了 internal 目录，在 internal 下的包只能被本项目的包导入，而不能被外部的包导入。</p>

<h3>1.2 Go 1.6 版本中，增加 vendor 目录</h3>

<p>为了解决版本依赖问题，Go 允许源码不在 GOPATH 中寻找依赖包，而是在 vendor 目录下面寻找依赖包。这样开发者就可以在 vendor 中自己管理依赖包的版本，从而解决不同开发环境依赖包版本不一致的问题。</p>

<p>vendor 机制和目录的引入，让 Go 第一次拥有了可重现构建的能力</p>

<h3>1.3 Go 1.13 版本中，增加了 go.sum 和 go.mod</h3>

<p>依旧是为了解决版本依赖的问题，vendor 机制有很多缺点，例如，需要手工管理依赖包版本，另外会给代码审核带来干扰等。于是 go module 出现了，引入了 go.mod 来明确了第三方包及其版本，可以实现精准构建。</p>

<h2>2. 典型结构布局</h2>
<pre class="chroma">- exe-layout
  - cmd/
    - app1/
      - main.go
    - app2/
      - main.go
  - go.mod
  - go.sum
  - internal
    - pkga/
      - pkga.go
    - pkgb/
      - pkgb.go
  - pkg1/
    - pkg1.go
  - pkg2/
    - pkg2.go 
  - vendor/
</pre>
<blockquote>
<p>vendor 目录是可选的，在某些没有公网访问的场景可用，使用vendor模式构建：<code>go build -mod=vendor</code></p>

<p>Go 1.14 版本及其后续版本，当项目根目录存在 vendor 目录时，默认采用 vendor 模式来构建应用。可以使用 <code>go build -mod=mod</code> 来切换到 Go Module 模式。详细说明参见<a href="https://go.dev/doc/go1.14">Go 1.14 changelog</a></p>
</blockquote>

<p>上面提到的例子有多个app构建，其实更建议使用下面app互相隔离的方式</p>
<pre class="chroma">- single-exe-layout
  - main.go
  - go.mod
  - go.sum
  - internal
    - pkga/
      - pkga.go
    - pkgb/
      - pkgb.go
  - pkg1/
    - pkg1.go
  - pkg2/
    - pkg2.go 
  - vendor/
</pre>
<p><strong>总结：虽然上面有提到了多种目录结构，但是 Go 官方并没有给出一个固定的目录结构范式。而且目前主流的开源项目的目录结构也都有着些许的差别，所以并不需要完全一对一的参照本文的模板来创建项目。</strong></p>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="go/go/go_1.1.1_code_struct.html">GO 1.1.1 程序结构和编译</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>25 Oct 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>1. hello world</h2>
<pre class="chroma"><span class="c1"># 在任意位置创建工程目录</span>
mkdir -p <span class="nv">$HOME</span>/goproj/helloworld
<span class="nb">cd</span> <span class="nv">$HOME</span>/goproj/helloworld

<span class="c1"># 创建第一个go文件main.go</span>
touch main.go
</pre>
<p><code>main.go</code></p>
<pre class="chroma"><span class="c1">// 包名称，整个go程序，只允许有一个main包
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="c1">// 引入标准库中的fmt目录下的所有包
</span><span class="c1"></span><span class="c1">// 这里的&#34;fmt&#34;指的是路径
</span><span class="c1"></span><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="c1">// main包中的main函数，这是整个程序的入口函数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// 这里的&#34;fmt&#34;指的是包名称
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello, world&#34;</span><span class="p">)</span>
<span class="p">}</span>
</pre>
<p>编译执行</p>
<pre class="chroma"><span class="c1"># 编译</span>
go build main.go

<span class="c1"># 执行</span>
./main
<span class="c1"># 在开发环境中，可以直接执行go run main.go来调试</span>
</pre>
<h2>2. 复杂项目</h2>

<p>正常的项目不止有一个go源文件，通常是多个包，每个包都有自己的第三方依赖。这种情况下编译过程如下</p>
<pre class="chroma"><span class="c1"># 1. 初始化mod</span>
go mod init github.com/xiaotuanyu120/goproj01
<span class="c1"># &#34;github.com/xiaotuanyu120/goproj01&#34; 代表的是&#34;模块路径&#34;</span>
<span class="c1"># 如果希望把project传到公网，就必须给一个可互联网访问的路径。</span>
<span class="c1"># 如果只是本地使用，可以用本地路径，比如&#34;projectA&#34;、&#34;somthing/a/project&#34;</span>

<span class="c1"># 最后一段为模块名称，&#34;.../mod_name&#34;</span>

<span class="c1"># 2. 维护mod文件</span>
go mod tidy
<span class="c1"># 这个命令会自动分析第三方依赖，下载第三方依赖包和它的依赖包到本地的$GOMODCACHE目录中，默认值是$HOME/go/pkg/mod</span>
<span class="c1"># 并会维护当前模块的go.mod和go.sum文件</span>

<span class="c1"># 3. 编译项目</span>
go build main.go
</pre>
        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="go/go/go_1.0.0_introduction.html">GO 1.0.0 go语言</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>25 Oct 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>0. go语言的诞生</h2>

<p>计算机领域中的任何事物的诞生，都是要解决一些老旧的无法忍受的问题而产生的。go语言也不例外，谷歌的三位大佬在等待C++数以小时计的编译期间做了一场普通的讨论。大白话就是，C和C++虽然性能够强，但是编译速度太慢、过于复杂、对并发支持度不高，python等动态语言虽然易于上手，但是性能太弱。于是他们想搞一个新语言，这就是go。</p>

<blockquote>
<p>三位谷歌大佬</p>

<ul>
<li>图灵奖获得者、C 语法联合发明人、Unix 之父肯·汤普森（Ken Thompson）</li>
<li>Plan 9 操作系统领导者、UTF-8 编码的最初设计者罗伯·派克（Rob Pike）</li>
<li>Java 的 HotSpot 虚拟机和 Chrome 浏览器的 JavaScript V8 引擎的设计者之一罗伯特·格瑞史莫（Robert Griesemer）</li>
</ul>
</blockquote>

<p>之后，他们使用一封邮件开始正式讨论这个设想</p>
<pre class="chroma">Date: Sun, 23 Sep 2007 23:33:41 -0700
From: &#34;Robert Griesemer&#34; &lt;gri@google.com&gt;
To: &#34;Rob &#39;Commander&#39; Pike&#34; &lt;r@google.com&gt;, ken@google.com
Subject: prog lang discussion
...
*** General:
Starting point: C, fix some obvious flaws, remove crud, add a few missing features
  - no includes, instead: import
  - no macros (do we need something instead?)
  - ideally only one file instead of a .h and .c file, module interface
should be extracted automatically
  - statements: like in C, though should fix &#39;switch&#39; statement
  - expressions: like in C, though with caveats (do we need &#39;,&#39; expressions?)
  - essentially strongly typed, but probably w/ support for runtime types
  - want arrays with bounds checking on always (except perhaps in &#39;unsafe mode&#39;-see section on GC)
  - mechanism to hook up GC (I think that most code can live w/ GC, but for a true systems
    programming language there should be mode w/ full control over memory allocation)
  - support for interfaces (differentiate between concrete, or implementation types, and abstract,
    or interface types)
  - support for nested and anonymous functions/closures (don&#39;t pay if not used)
  - a simple compiler should be able to generate decent code
  - the various language mechanisms should result in predictable code
</pre>
<blockquote>
<p>几个事实：</p>

<ul>
<li>go语言的名字，就是go，不是Golang。Golang只是go官方网站的名称，因为go.com已经被使用了。</li>
<li>go语言虽然在谷歌内部始于2007年9月20日，但是公布于众是在2009年10月30日，10天后的2009年11月10日，谷歌官宣Go语言项目开源，这一天被官方确定为Go语言的诞生日。</li>
<li>go语言使用gopher（地鼠）代指go语言开发者。</li>
</ul>
</blockquote>

<h2>1. go语言的发展</h2>

<p>2012 年 3 月 28 日，Go 1.0 版本正式发布，同时 Go 官方发布了“Go 1 兼容性”承诺：<strong>只要符合 Go 1 语言规范的源代码，Go 编译器将保证向后兼容（backwards compatible），也就是说我们使用新版编译器也可以正确编译用老版本语法编写的代码。</strong></p>

<h3><strong>go语言的杀手级项目</strong></h3>

<p><code>Docker</code>, <code>Kubernetes</code>, <code>Prometheus</code>, <code>Ethereum</code>, <code>Istio</code>, <code>CockroachDB</code>, <code>InfluxDB</code>, <code>Terraform</code>, <code>Etcd</code>, <code>Consul</code> 等</p>

<h3><strong>go语言大事记</strong></h3>

<ul>
<li>2012：Go 1.0 发布，同时承诺“Go 1 兼容性”</li>
<li>2014：Go 1.4 发布，最后一个由C语言实现编译器和运行时的版本</li>
<li>2015：Go 1.5 发布，实现自举，大幅降低GC延迟</li>
<li>2018：Go 1.11 发布，引入新的Go包管理机制 go module</li>
<li>2021：Go 1.16 发布，Go module成为默认包管理机制</li>
<li>2022：Go 1.18 发布，支持泛型</li>
</ul>

<h2>2. go语言的设计哲学</h2>

<p>现代的编程语言有很多，每个语言都根据自己的设计哲学做了不同的取舍。</p>

<p>而go语言的设计哲学，可以做以下归类</p>

<ul>
<li>简单，不做特性缝合怪，致力于做减法，保持简单</li>
<li>显式，明确优于模糊</li>
<li>组合，没有选择面向对象（落笔之初对这里理解不深，留白，不误导他人）</li>
<li>并发，使用用户空间的goroutine来取代cpu中的线程调度，以达到轻量级调度，面向多核cpu的大规模并发的效果。并且增加了channel和select的辅助并发的原语。</li>
<li>面向工程，提供完善的工程支持工具，来解决程序构建慢、依赖管理失控、代码难于理解、跨语言构建难等问题</li>
</ul>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="service/tomcat/tomcat_1.0.0_what_is_jakarta_ee_and_tomcat.html">tomcat 1.0.0 Jakarta EE 和 Tomcat</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>05 Oct 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>0. 什么是Jakarta EE？</h2>

<p>Jakarta EE是用于开发云原生 Java 应用程序的开源框架。</p>

<p>其历史发展为，sun公司的JAVA EE（Enterprise Edition），到oracle收购sun，然后捐JAVA EE给eclipse。eclipse将JAVA EE更名为EE4J（Eclipse Enterprise for Java）。因eclipse在javax和java商标上无法与oracle达成一致，oracle将JAVA EE更名为Jakarta EE。</p>

<h2>1. 什么是Tomcat？</h2>

<p>Apache Tomcat 是 Jakarta Servlet、Jakarta Server Pages、Jakarta Expression Language、Jakarta WebSocket、Jakarta Annotations 和 Jakarta Authentication 规范的开源实现。</p>

<p>Jakarta EE平台由JAVA EE进化而来。Tomcat 10和之后的版本实现的Jakarta EE。而Tomcat 9和之前的版本实现的是JAVA EE。</p>

<blockquote>
<ul>
<li>Jakarta Servlet: 虽然Servlet可以响应多种请求，但最常见的用途是作为Web容器，用以托管web应用。</li>
<li>Jakarta Server Pages: JSP，是帮助软件开发人员根据HTML、XML、SOAP或其他文档类型创建动态生成网页的技术集合。</li>
<li>Jakarta Expression Language: 是一种特殊目的编程语言，主要用于在Jakarta EE Web应用程序的网页中嵌入和评估表达式。</li>
<li>Jakarta WebSocket: 顾名思义，是web socket。</li>
<li>Jakarta Annotations: 顾名思义，是java 注解。</li>
<li>Jakarta Authentication: 顾名思义，是java 授权。</li>
</ul>
</blockquote>

<h2>2. Tomcat版本</h2>

<p>不同的tomcat版本支持的JAVA语言和Jakarta EE组件的版本不同。</p>

<blockquote>
<p><a href="https://tomcat.apache.org/whichversion.html">选择tomcat版本</a></p>
</blockquote>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="linux/shell/shell_1.2_read.html">SHELL: 1.2 read</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>21 Sep 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h3>0. read简介</h3>

<p>read是将标准输入中读取逻辑行，然后将其转换成一个或多个变量的工具。一般是从文件中读取内容，然后赋值给shell脚本的变量。</p>

<h3>1. read变量和选项</h3>

<p>变量：</p>

<ul>
<li><code>IFS</code>: 逻辑行中用于分隔不同field的分隔符</li>
</ul>

<blockquote>
<p>其他变量参见 <a href="https://man7.org/linux/man-pages/man1/read.1p.html">read manual</a></p>
</blockquote>

<p>选项：</p>

<ul>
<li><code>-r</code>: 把转义符<code>\</code>当做普通字符。</li>
</ul>

<h3>2. 实例：读取配置文件</h3>

<p>配置文件内容：<code>var.conf</code></p>
<pre class="chroma">cat <span class="s">&lt;&lt; EOF &gt; var.conf
</span><span class="s">id=01
</span><span class="s">type=apple
</span><span class="s">EOF</span>
</pre>
<p>读取配置的shell脚本：<code>load_var.sh</code></p>
<pre class="chroma"><span class="cp">#!/bin/bash
</span><span class="cp"></span>
<span class="c1"># read content from conf file and transfer it to var value pair in shell script</span>
#
<span class="c1"># EXAMPLE:</span>
#
<span class="c1"># var.conf&#39;s content</span>
<span class="c1"># ==================================</span>
<span class="c1"># id=01</span>
<span class="c1"># type=apple</span>
<span class="c1"># ==================================</span>
#
<span class="c1"># this script will read one line each time,</span>
<span class="c1"># for example the first line &#34;id=01&#34;, and</span>
<span class="c1"># separate it by &#34;=&#34;, load the two part to</span>
<span class="c1"># var key and value:</span> 
<span class="c1">#     key=id; value=01</span>
<span class="c1"># then transfer it to new var pair in script</span>
<span class="c1">#     id=01</span>

<span class="nb">set</span> -e

<span class="k">while</span> <span class="nv">IFS</span><span class="o">=</span><span class="s1">&#39;=&#39;</span> <span class="nb">read</span> -r key value
<span class="k">do</span>
    <span class="c1"># ensure key and value is not empty</span>
    <span class="k">if</span> <span class="o">[</span><span class="o">[</span> -z <span class="si">${</span><span class="nv">key</span><span class="si">}</span> <span class="o">]</span><span class="o">]</span> <span class="o">||</span> <span class="o">[</span><span class="o">[</span> -z <span class="si">${</span><span class="nv">value</span><span class="si">}</span> <span class="o">]</span><span class="o">]</span><span class="p">;</span> <span class="k">then</span>
        <span class="k">continue</span>
    <span class="k">fi</span>

    <span class="c1"># assign the content of var value to var which name is the content of var key</span> 
    <span class="c1"># EXAMPLE:</span>
    <span class="c1">#     orinal vars: key=foo; value=bar</span>
    <span class="c1">#     new var:     foo=bar</span>
    <span class="k">if</span> <span class="o">[</span><span class="o">[</span> <span class="si">${</span><span class="nv">key</span><span class="si">}</span> <span class="o">=</span><span class="o">=</span> <span class="s2">&#34;id&#34;</span> <span class="o">]</span><span class="o">]</span> <span class="o">||</span> <span class="o">[</span><span class="o">[</span> <span class="si">${</span><span class="nv">key</span><span class="si">}</span> <span class="o">=</span><span class="o">=</span> <span class="s2">&#34;type&#34;</span> <span class="o">]</span><span class="o">]</span><span class="p">;</span> <span class="k">then</span>
        <span class="nb">eval</span> <span class="s2">&#34;</span><span class="nv">$key</span><span class="s2">=</span><span class="nv">$value</span><span class="s2">&#34;</span>
    <span class="k">fi</span>
<span class="k">done</span> &lt; ./var.conf

<span class="nb">printf</span> <span class="s2">&#34;  id = %s\ntype = %s\n&#34;</span> <span class="si">${</span><span class="nv">id</span><span class="si">}</span> <span class="si">${</span><span class="nv">type</span><span class="si">}</span>
</pre>
<p>执行后的输出演示</p>
<pre class="chroma">sh load_var.sh
  <span class="nv">id</span> <span class="o">=</span> <span class="m">01</span>
<span class="nb">type</span> <span class="o">=</span> apple
</pre>
        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="cryptography/basic/openssl_1.3.1_usage.html">openssl 1.3.1 SSL DEBUG: s_client</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>09 Sep 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h2>1. s_client</h2>

<p>简介：SSL/TLS 客户端程序，用于调试和SSL服务器的连接。</p>
<pre class="chroma">openssl s_client [-connect host:port] [-servername name] [-verify depth] [-verify_return_error] [-cert filename] [-certform DER|PEM] [-key filename] [-keyform DER|PEM] [-pass arg] [-CApath directory] [-CAfile filename] [-no_alt_chains] [-reconnect] [-pause] [-showcerts] [-debug] [-msg] [-nbio_test] [-state] [-nbio] [-crlf] [-ign_eof] [-no_ign_eof] [-quiet] [-ssl2] [-ssl3] [-tls1] [-no_ssl2] [-no_ssl3] [-no_tls1] [-no_tls1_1] [-no_tls1_2] [-fallback_scsv] [-bugs] [-sigalgs sigalglist] [-curves curvelist] [-cipher cipherlist] [-serverpref] [-starttls protocol] [-engine id] [-tlsextdebug] [-no_ticket] [-sess_out filename] [-sess_in filename] [-rand file(s)] [-serverinfo types] [-status] [-alpn protocols] [-nextprotoneg protocols]
</pre>
<p><strong>选项介绍：</strong></p>

<ul>
<li><code>-connect host:port</code>: 指定连接主机和端口</li>
<li><code>-servername name</code>: TLS SNI (Server Name Indication)</li>
<li><code>-cert certname</code>: 客户端证书（如果使用双向认证的话）</li>
<li><code>-certform format</code>: 客户端证书格式，<code>DER,PEM</code>，默认值<code>PEM</code></li>
<li><code>-key keyfile</code>: 客户端私钥（如果使用双向认证的话）</li>
<li><code>-keyform format</code>: 客户端私钥格式，<code>DER,PEM</code>，默认值<code>PEM</code></li>
<li><code>-pass arg</code>: 客户端私钥密码</li>
<li><code>-tls1,-tls1_1,-tls1_2,-no_ssl2,-no_ssl3,-no_tls1,-no_tls1_1,-no_tls1_2</code>: 指定<code>ssl protocol</code></li>
<li><code>-cipher cipherlist</code>: 指定ssl连接的加密算法</li>
</ul>

<blockquote>
<p>加密算法详情见：<a href="https://www.openssl.org/docs/man1.0.2/man1/ciphers.html">ciphers</a></p>

<p>openssl ssl debug工具详细用法：<a href="https://www.openssl.org/docs/man1.0.2/man1/openssl-s_client.html">openssl s_client</a></p>
</blockquote>

<h2>2. s_client示例</h2>
<pre class="chroma">openssl s_client -cert client.crt -key client.key -tls1_2 -connect 127.0.0.1:80 -servername www.test.com
</pre>
<p>常见的使用场景：</p>

<ul>
<li>debug服务器是否开启了ssl的特定版本；</li>
<li>debug特定的ssl加密算法；</li>
</ul>

        </div>

        <div class="article-summary">
        <div class="article-title">
          <a href="linux/advance/network_theory-TCP-IP-note.html">网络: 理论 - TCP/IP详解读书笔记</a>
        </div>
        <div>
          <hr style="border: 0; border-top: 1px dashed #a2a9b6">
        </div>
        <div class="postDate">
          <p>18 Aug 2022</p>
        </div>
        <div>
          <hr style="border: 0; border-bottom: 1px dashed #a2a9b6">
        </div>
<h1>一、概述</h1>

<h2>1. 分层</h2>

<p>网络协议通常针对不同层次分别开发，每一层分别负责不同的通信功能。TCP/IP是一个协议族，是不同层次的协议的组合。TCP/IP通常被认为是一个四层协议系统。</p>

<ul>
<li>应用层，telnet、ftp、email</li>
<li>运输层，tcp、udp</li>
<li>网络层，ip、icmp、igmp</li>
<li>链路层，设备驱动程序及接口卡</li>
</ul>

<blockquote>
<p>通常应用层是运行在linux的用户空间，而其他三层是运行在linux的内核空间。</p>

<p>网桥和路由器</p>

<ul>
<li>网桥是在链路层上对网络进行互联，网桥使得多个局域网组合在一起，对于上层来说就好像是一个局域网。</li>
<li>路由器是在网络层上对网络进行互联，TCP/IP倾向于使用路由器而不是网桥来连接网络。</li>
</ul>
</blockquote>

<h2>2. 互联网地址</h2>

<p>如下图，<code>net-id</code>代表网络号；<code>host-id</code>代表主机号</p>
<pre class="chroma">CLASS A
IP RANGE: 1.0.0.0 - 126.255.255.255
MASK: 255.0.0.0
    7 bits        24 bits
┌─┬───────┬────────────────────────┐
│0│net-id │        host-id         │
└─┴───────┴────────────────────────┘

CLASS B
IP RANGE: 128.0.0.0 - 191.255.255.255
MASK: 255.255.0.0
        14 bits        16 bits
┌──┬──────────────┬────────────────┐
│10│   net-id     │   host-id      │
└──┴──────────────┴────────────────┘

CLASS C
IP RANGE: 192.0.1.0 - 223.255.255.255
MASK: 255.255.255.0
         21 bits            8 bits
┌───┬─────────────────────┬────────┐
│110│       net-id        │host-id │
└───┴─────────────────────┴────────┘

CLASS D
IP RANGE: 224.0.0.0 - 239.255.255.255
               28 bits
┌────┬─────────────────────────────┐
│1110│        multi-broadcast      │
└────┴─────────────────────────────┘

CLASS E: 240.0.0.0 - 255.255.255.254
               27 bits
┌─────┬────────────────────────────┐
│11110│        reserved            │
└─────┴────────────────────────────┘
</pre>
<h2>3. 用途</h2>

<p>TCP/IP中，网络层和运输层的区别最为关键：网络层（IP）提供点对点的服务，而运输层（TCP和UDP）提供端对端的服务。</p>

<p>互联网是网络的网络，通过IP把网络连接起来，端口号用来标识互相通信的应用程序。</p>

<h1>二、链路层</h1>

<h2>1. 回环网络</h2>

<p>对于回环网络的实现，并不会省略传输层和网络层的传输过程，大多数的产品还是照样完成传输层和网络层的所有过程，只是当IP数据报离开网络层时把它返回给自己。</p>

<p><img src="/static/images/docs/linux/advance/network-theory-tcp-ip.png" alt="" /></p>

<p>上图的关键点：</p>

<ul>
<li>传给回环网络（127.0.0.1）的任何数据都作为ip输入</li>
<li>传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上。这是因为广播传送和多播传送的定义（第12章）包含主机本身。</li>
<li>任何传给该主机I P地址的数据均送到环回接口。</li>
</ul>

<p>看上去回环网络的实现中又走了一遍传输层和网络层效率不高。但是这样是简化了设计，相当于把回环网络当成了网络层下面的一个链路层。网络层把一份数据报传送给环回接口，就像传给其他链路层一样，只不过环回接口把它返回到IP的输入队列中。</p>

<blockquote>
<p>虽然回环网络会走一遍传输层和网络层的过程，但是回环网络的包不会出现在网络中。</p>
</blockquote>

<h2>2. MTU 最大传输单元</h2>

<p>如果IP层有一个数据报要传，而且数据的长度比链路层的MTU还大，那么IP层就需要进行分片，把数据报分成若干片，这样每一片都小于MTU。</p>

<p><strong>查看linux系统中网卡设备的MTU</strong></p>
<pre class="chroma">netstat -in
Kernel Interface table
Iface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg
eth0             <span class="m">1500</span>     <span class="m">2975</span>      <span class="m">0</span>      <span class="m">0</span> <span class="m">0</span>          <span class="m">1329</span>      <span class="m">0</span>      <span class="m">0</span>      <span class="m">0</span> BMRU
lo              <span class="m">65536</span>        <span class="m">0</span>      <span class="m">0</span>      <span class="m">0</span> <span class="m">0</span>             <span class="m">0</span>      <span class="m">0</span>      <span class="m">0</span>      <span class="m">0</span> LRU
</pre>
<h3>2.1 路径MTU</h3>

<p>在同一个网络中的两台主机进行通信时，该网络的MTU是非常重要的。但是如果是不同网络中的两台主机进行通信时，那么重要的就不在是两台主机各自所在网络的MTU，而是两台主机中间路径上经过的最小MTU。这被称为路径MTU。</p>

<p>但是路径MTU不一定是一个常数，因为这取决于网络路由的路径。而路由的选择不一定是对称的，A到B和B到A不一定是一致的，因此路径MTU在这两个方向上也不一定是一致的。</p>

<p>这里就牵扯到一个重要的问题，路径MTU发现机制，这个机制有点复杂，后面会讨论。</p>

<h1>三、IP: 网际协议</h1>

<h2>1. 引言</h2>

<p>IP是TCP/IP协议族中最核心的协议。所有的TCP、UDP、ICMP和IGMP都以IP数据报格式传输。</p>

<ul>
<li><strong>不可靠</strong>，意思是不保证IP数据报能成功的到达目的地，如果发生某种错误，例如一个路由器的缓冲区用完了，IP有一个简单的处理算法，丢弃该数据报，然后发送ICMP给信源端。任何<strong>可靠性</strong>的需求必须由上层协议来完成，比如说TCP。</li>
<li><strong>无连接</strong>，意思是IP不维护任何关于后续数据报的状态信息。每个数据报的传输都是独立的。这代表如果两个连续发送的数据报，有可能因为路由选择不同，导致后发送的数据报先到达。</li>
</ul>

<h2>2. IP首部</h2>

<p><img src="/static/images/docs/linux/advance/network-theory-tcp-ip-01.png" alt="" /></p>

<p>普通的IP首部有20个字节长，除非含有选项字段。</p>

<p>最高位在左边，记为0bit，最低位在右边，记为31bit。4个字节，32个bit的传输顺序为，首先为0-7bit，其次为8-15bit，然后是16-23bit，最后是24-31bit。这种传输方式被称为big endian字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称之为网络字节序。以其他形式储存二进制整数的机器，比如little endian格式，则必须在传输数据之前把首部转换成网络字节序。</p>

<p>目前的协议版本号是4，因此IP也被称为IPv4。</p>

<p>首部长度指的是首部占32bit字的数目，包括任何选项。由于它是一个4字节（图中的宽度）字段，因此首部最长为60个字节。普通IP数据报（没有任何选项）字段的值是5。</p>

<p>服务类型（TOS）字段包括</p>

<ul>
<li>一个3bit的优先权子字段（现在已被忽略）</li>
<li>4bit的TOS子字段

<ul>
<li>最小时延</li>
<li>最大吞吐量</li>
<li>最高可靠性</li>
<li>最小费用</li>
</ul></li>
<li>1bit的未用位，目前必须设定为0</li>
</ul>

<blockquote>
<p>4bit的TOS子字段，如果全部设定为0，那就意味着是一般服务。</p>

<p>RFC <sup>1340</sup>&frasl;<sub>1349</sub> 详细的描述了如何设定TOS和描述了TOS特性。</p>
</blockquote>

<p>下图列出了对不同应用建议的TOS值。最后一列中给出来的是十六进制值。
<img src="/static/images/docs/linux/advance/network-theory-tcp-ip-02.png" alt="" /></p>

<p>总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度字段和总长度字段，就可以知道IP数据报中的数据内容的起始位置和长度。最长是65535字节。</p>

<p>总长度字段是IP首部中必要的内容。因为有一些数据链路（如以太网）需要填充一些数据以达到小长度。以太网的最小帧是46字节。</p>

<p>标识字段唯一的标识主机发送的每一份数据报。通常每发送一份报文，它的数值就会加1。</p>

<p>TTL（time to live）生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。其初始值由源主机设定（32或64），一旦经过一个处理它的路由器，它的值就减1。当该字段为0时，该报文会被抛弃，并发送ICMP报文通知源主机。</p>

<p>根据协议字段可以判断是哪个协议向IP传送数据。</p>

<p>首部校验和字段是根据IP首部计算的校验和码。</p>

<p>每一份IP数据报文都包含源地址和目的地址。</p>

<p>最后一个字段是任选项，是数据报中可变长的可选信息。这些选项很少被使用，并非所有的主机和路由器支持这些字段。选项字段一直都是以32bit为边界，不足的地方以0补齐。这样就保证了所有的IP首部都是32bit的整数倍。</p>

<h2>3. IP路由选择</h2>

<p>IP的路由非常简单，如果两个主机直接点对点或者在同一个本地网络中（以太网或令牌网），那么IP数据报就直接发送到目的主机上。否则，主机把数据发给默认的路由器上，由路由器来转发该数据报。</p>

<p>在一般的体制中，IP可以从TCP、UDP、ICMP和IGMP接收数据报（本地生成）并进行发送，或者从一个网络接口接收数据报（待转发的数据报）并进行发送。IP层在内存中存有一个路由表。当收到一个数据报并进行发送时，它都要对该表搜索一次。当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果确实是这样的，数据报就会被送到由IP首部协议字段所指定的协议模块进行处理。如果数据报的目的地址不是这些地址，那么如果IP层被设置为路由器的功能，那么就对数据报进行转发（转发过程如下）；如果IP层没有被设置为路由器的功能，数据报将会被丢弃。</p>

<p>路由表中的每一项都包含以下信息：</p>

<ul>
<li>目的IP地址。</li>
<li>下一跳路由器的IP地址，或者有直接连接的网络IP地址。下一跳路由器是指一个直接相连网络上的路由器，通过它可以转发数据报。</li>
<li>标志。其中一个标志指明目的IP地址是一个网络地址还是一个主机地址，另外一个标志指明下一跳路由器是否为真正的下一站路由器，还是一个直接相连的接口。</li>
<li>为数据报的传输指定一个网络接口</li>
</ul>

<p>IP路由选择是逐跳地进行的。IP并不知道到达任何目的的完整路径，所有IP路由选择只为数据报传输指定下一跳路由器的IP地址。它假定下一跳路由器比发送数据报的主机更接近目的地，而且下一跳路由器与该主机是直接相连的。</p>

<p>IP路由主要完成以下功能：</p>

<ol>
<li>搜索路由表，寻找能与目的IP地址完全匹配的表目（网络号和主机号都要匹配）。如果找到，则把数据报发送给该表目指定的下一跳路由器或直接相连的网络接口（取决于标志字段的值）。</li>
<li>搜索路由表，寻找能与目的IP地址完全匹配的表目。如果找到，则把数据报发送给该表目指定的下一跳路由器或直接相连的网络接口（取决于标志字段的值）。目的网络上的所有主机都可以通过这个表目来处置。例如，一个以太网上的所有主机都是通过这种表目进行寻径的。这种搜索网络的匹配方法必须考虑到可能的子网掩码。</li>
<li>搜索路由表，寻找标为“默认（default）”的表目。如果找到，则把报文发送给该表目指定的下一站路由器。</li>
</ol>

<p>如果上述的这些步骤都没有成功，那么该数据报就不能发送。如果不能传送的数据报来自于本机，那么一般会向生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。</p>

<p>完整主机地址匹配在网络号匹配之前执行。只有当它们都失败后，才会选择默认路由。</p>

<blockquote>
<p>几个额外的知识点：</p>

<ul>
<li>数据报中的目的IP地址始终不会发生任何变化，所有的路由选择决策都是基于这个目的IP地址。</li>
<li>每个链路层可能具有不同的数据帧首部，而且链路层的目的地址（如果有的话）始终指向的是下一跳的链路层地址。以太网的链路层目的地址一般通过ARP获得，而SLIP这种点对点的链路就不需要链路层首部（因为它是点对点的）。</li>
</ul>
</blockquote>

<h2>4. 子网寻址</h2>

<p>现在所有的主机都要求支持子网编址（RFC950），不是把IP地址看成单纯的一个网络号和主机号组成，而是把主机号再分成一个子网号和主机号。</p>

<p>这样做的原因是因为A类和B类地址为主机号分配了太多的空间，可分别容纳的主机数为2^24-2和2^16-2。事实上，在一个网络中人们并不安排这么多的主机。由于全0和全1的主机号都是无效的，所以我们总是把总数减去2.</p>

<p>在InterNIC获得某类IP网络号之后，就可以进行子网划分。例如获得一个B类网络号140.252，在其下面划分成多个子网，可以将B类网络号剩下的16位地址中，前8位作为子网号，后8位作为主机号。用一个B类网络号然后分子网的方式，和直接采取同样数量的C类地址的区别在于，同一个B类地址，外部网络只需要知道一个路由表目即可，而使用C类却需要多个路由表目。因此，子网划分缩减了路由表的规模。</p>

<h2>5. 子网掩码</h2>

        </div>

    </div>

  </div>
</body>

<footer>
    <div class="container">
        <div class="row footer-links">
            <div class="col-lg-2 col-sm-2">
                <h3>友情链接</h3>
                <ul>
                    <li><a href="">友链位招租</a></li>
                    <li><a href="">友链位招租</a></li>
                </ul>
            </div>
            <div class="col-lg-2 col-sm-2">
                <h3>没想好</h3>
                <ul>
                    <li><a href="">我爸没想好</a></li>
                    <li><a href="">我哥说我爸没想好</a></li>
                </ul>
            </div>
            <div class="col-lg-2 col-sm-2">
                <h3>Hooray</h3>
                <ul>
                    <li><a href="">Hooray</a></li>
                    <li><a href="">What are we Hooray For?</a></li>
                </ul>
            </div>
            <div class="col-lg-2 col-sm-2">
                <h3>前面的footer太浪了</h3>
                <ul>
                    <li><a href="">就是就是</a></li>
                    <li><a href="">偷偷的表示羡慕</a></li>
                </ul>
            </div>
            <div class="col-lg-4 col-sm-4">
                <h3>网站信息</h3>
                <a class="" href="" target="_blank"></a>
                <a class="" href="" target="_blank"></a>
                <a class="" href="" target="_blank"></a>
                <a class="" href="" target="_blank"></a>
                <div class="fine-print">
                    <p>网战由以下技术支撑</p>
                    <ul>
                        <li>Markdown Processor: <a href="https://github.com/russross/blackfriday/tree/v2">Blackfriday V2</a></li>
                        <li>Renderer Engine: <a href="https://github.com/Depado/bfchroma/">bfchroma</a></li>
                        <li>Syntax Highlighter: <a href="https://github.com/alecthomas/chroma">Chroma</a></li>
                        <li>Coding Language: <a href="https://go.dev/">Golang</a></li>
                        <li>Others: Markdown, HTML, CSS</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</footer>

</html>